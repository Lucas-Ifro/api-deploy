
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model aluno
 * 
 */
export type aluno = $Result.DefaultSelection<Prisma.$alunoPayload>
/**
 * Model aula
 * 
 */
export type aula = $Result.DefaultSelection<Prisma.$aulaPayload>
/**
 * Model feito
 * 
 */
export type feito = $Result.DefaultSelection<Prisma.$feitoPayload>
/**
 * Model grupo
 * 
 */
export type grupo = $Result.DefaultSelection<Prisma.$grupoPayload>
/**
 * Model modulo
 * 
 */
export type modulo = $Result.DefaultSelection<Prisma.$moduloPayload>
/**
 * Model permissoes
 * 
 */
export type permissoes = $Result.DefaultSelection<Prisma.$permissoesPayload>
/**
 * Model professor
 * 
 */
export type professor = $Result.DefaultSelection<Prisma.$professorPayload>
/**
 * Model rota
 * 
 */
export type rota = $Result.DefaultSelection<Prisma.$rotaPayload>
/**
 * Model turma
 * 
 */
export type turma = $Result.DefaultSelection<Prisma.$turmaPayload>
/**
 * Model usuario
 * 
 */
export type usuario = $Result.DefaultSelection<Prisma.$usuarioPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Alunos
 * const alunos = await prisma.aluno.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Alunos
   * const alunos = await prisma.aluno.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.aluno`: Exposes CRUD operations for the **aluno** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alunos
    * const alunos = await prisma.aluno.findMany()
    * ```
    */
  get aluno(): Prisma.alunoDelegate<ExtArgs>;

  /**
   * `prisma.aula`: Exposes CRUD operations for the **aula** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Aulas
    * const aulas = await prisma.aula.findMany()
    * ```
    */
  get aula(): Prisma.aulaDelegate<ExtArgs>;

  /**
   * `prisma.feito`: Exposes CRUD operations for the **feito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feitos
    * const feitos = await prisma.feito.findMany()
    * ```
    */
  get feito(): Prisma.feitoDelegate<ExtArgs>;

  /**
   * `prisma.grupo`: Exposes CRUD operations for the **grupo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grupos
    * const grupos = await prisma.grupo.findMany()
    * ```
    */
  get grupo(): Prisma.grupoDelegate<ExtArgs>;

  /**
   * `prisma.modulo`: Exposes CRUD operations for the **modulo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modulos
    * const modulos = await prisma.modulo.findMany()
    * ```
    */
  get modulo(): Prisma.moduloDelegate<ExtArgs>;

  /**
   * `prisma.permissoes`: Exposes CRUD operations for the **permissoes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissoes
    * const permissoes = await prisma.permissoes.findMany()
    * ```
    */
  get permissoes(): Prisma.permissoesDelegate<ExtArgs>;

  /**
   * `prisma.professor`: Exposes CRUD operations for the **professor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Professors
    * const professors = await prisma.professor.findMany()
    * ```
    */
  get professor(): Prisma.professorDelegate<ExtArgs>;

  /**
   * `prisma.rota`: Exposes CRUD operations for the **rota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rotas
    * const rotas = await prisma.rota.findMany()
    * ```
    */
  get rota(): Prisma.rotaDelegate<ExtArgs>;

  /**
   * `prisma.turma`: Exposes CRUD operations for the **turma** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Turmas
    * const turmas = await prisma.turma.findMany()
    * ```
    */
  get turma(): Prisma.turmaDelegate<ExtArgs>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.usuarioDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    aluno: 'aluno',
    aula: 'aula',
    feito: 'feito',
    grupo: 'grupo',
    modulo: 'modulo',
    permissoes: 'permissoes',
    professor: 'professor',
    rota: 'rota',
    turma: 'turma',
    usuario: 'usuario'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "aluno" | "aula" | "feito" | "grupo" | "modulo" | "permissoes" | "professor" | "rota" | "turma" | "usuario"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      aluno: {
        payload: Prisma.$alunoPayload<ExtArgs>
        fields: Prisma.alunoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.alunoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alunoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.alunoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alunoPayload>
          }
          findFirst: {
            args: Prisma.alunoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alunoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.alunoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alunoPayload>
          }
          findMany: {
            args: Prisma.alunoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alunoPayload>[]
          }
          create: {
            args: Prisma.alunoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alunoPayload>
          }
          createMany: {
            args: Prisma.alunoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.alunoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alunoPayload>
          }
          update: {
            args: Prisma.alunoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alunoPayload>
          }
          deleteMany: {
            args: Prisma.alunoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.alunoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.alunoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alunoPayload>
          }
          aggregate: {
            args: Prisma.AlunoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAluno>
          }
          groupBy: {
            args: Prisma.alunoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlunoGroupByOutputType>[]
          }
          count: {
            args: Prisma.alunoCountArgs<ExtArgs>
            result: $Utils.Optional<AlunoCountAggregateOutputType> | number
          }
        }
      }
      aula: {
        payload: Prisma.$aulaPayload<ExtArgs>
        fields: Prisma.aulaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.aulaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aulaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.aulaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aulaPayload>
          }
          findFirst: {
            args: Prisma.aulaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aulaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.aulaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aulaPayload>
          }
          findMany: {
            args: Prisma.aulaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aulaPayload>[]
          }
          create: {
            args: Prisma.aulaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aulaPayload>
          }
          createMany: {
            args: Prisma.aulaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.aulaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aulaPayload>
          }
          update: {
            args: Prisma.aulaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aulaPayload>
          }
          deleteMany: {
            args: Prisma.aulaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.aulaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.aulaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aulaPayload>
          }
          aggregate: {
            args: Prisma.AulaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAula>
          }
          groupBy: {
            args: Prisma.aulaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AulaGroupByOutputType>[]
          }
          count: {
            args: Prisma.aulaCountArgs<ExtArgs>
            result: $Utils.Optional<AulaCountAggregateOutputType> | number
          }
        }
      }
      feito: {
        payload: Prisma.$feitoPayload<ExtArgs>
        fields: Prisma.feitoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.feitoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feitoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.feitoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feitoPayload>
          }
          findFirst: {
            args: Prisma.feitoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feitoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.feitoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feitoPayload>
          }
          findMany: {
            args: Prisma.feitoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feitoPayload>[]
          }
          create: {
            args: Prisma.feitoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feitoPayload>
          }
          createMany: {
            args: Prisma.feitoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.feitoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feitoPayload>
          }
          update: {
            args: Prisma.feitoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feitoPayload>
          }
          deleteMany: {
            args: Prisma.feitoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.feitoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.feitoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feitoPayload>
          }
          aggregate: {
            args: Prisma.FeitoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeito>
          }
          groupBy: {
            args: Prisma.feitoGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeitoGroupByOutputType>[]
          }
          count: {
            args: Prisma.feitoCountArgs<ExtArgs>
            result: $Utils.Optional<FeitoCountAggregateOutputType> | number
          }
        }
      }
      grupo: {
        payload: Prisma.$grupoPayload<ExtArgs>
        fields: Prisma.grupoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.grupoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.grupoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>
          }
          findFirst: {
            args: Prisma.grupoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.grupoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>
          }
          findMany: {
            args: Prisma.grupoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>[]
          }
          create: {
            args: Prisma.grupoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>
          }
          createMany: {
            args: Prisma.grupoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.grupoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>
          }
          update: {
            args: Prisma.grupoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>
          }
          deleteMany: {
            args: Prisma.grupoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.grupoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.grupoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>
          }
          aggregate: {
            args: Prisma.GrupoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrupo>
          }
          groupBy: {
            args: Prisma.grupoGroupByArgs<ExtArgs>
            result: $Utils.Optional<GrupoGroupByOutputType>[]
          }
          count: {
            args: Prisma.grupoCountArgs<ExtArgs>
            result: $Utils.Optional<GrupoCountAggregateOutputType> | number
          }
        }
      }
      modulo: {
        payload: Prisma.$moduloPayload<ExtArgs>
        fields: Prisma.moduloFieldRefs
        operations: {
          findUnique: {
            args: Prisma.moduloFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$moduloPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.moduloFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$moduloPayload>
          }
          findFirst: {
            args: Prisma.moduloFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$moduloPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.moduloFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$moduloPayload>
          }
          findMany: {
            args: Prisma.moduloFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$moduloPayload>[]
          }
          create: {
            args: Prisma.moduloCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$moduloPayload>
          }
          createMany: {
            args: Prisma.moduloCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.moduloDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$moduloPayload>
          }
          update: {
            args: Prisma.moduloUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$moduloPayload>
          }
          deleteMany: {
            args: Prisma.moduloDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.moduloUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.moduloUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$moduloPayload>
          }
          aggregate: {
            args: Prisma.ModuloAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModulo>
          }
          groupBy: {
            args: Prisma.moduloGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuloGroupByOutputType>[]
          }
          count: {
            args: Prisma.moduloCountArgs<ExtArgs>
            result: $Utils.Optional<ModuloCountAggregateOutputType> | number
          }
        }
      }
      permissoes: {
        payload: Prisma.$permissoesPayload<ExtArgs>
        fields: Prisma.permissoesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissoesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissoesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissoesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissoesPayload>
          }
          findFirst: {
            args: Prisma.permissoesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissoesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissoesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissoesPayload>
          }
          findMany: {
            args: Prisma.permissoesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissoesPayload>[]
          }
          create: {
            args: Prisma.permissoesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissoesPayload>
          }
          createMany: {
            args: Prisma.permissoesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.permissoesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissoesPayload>
          }
          update: {
            args: Prisma.permissoesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissoesPayload>
          }
          deleteMany: {
            args: Prisma.permissoesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permissoesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.permissoesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissoesPayload>
          }
          aggregate: {
            args: Prisma.PermissoesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissoes>
          }
          groupBy: {
            args: Prisma.permissoesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissoesGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissoesCountArgs<ExtArgs>
            result: $Utils.Optional<PermissoesCountAggregateOutputType> | number
          }
        }
      }
      professor: {
        payload: Prisma.$professorPayload<ExtArgs>
        fields: Prisma.professorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.professorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.professorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professorPayload>
          }
          findFirst: {
            args: Prisma.professorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.professorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professorPayload>
          }
          findMany: {
            args: Prisma.professorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professorPayload>[]
          }
          create: {
            args: Prisma.professorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professorPayload>
          }
          createMany: {
            args: Prisma.professorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.professorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professorPayload>
          }
          update: {
            args: Prisma.professorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professorPayload>
          }
          deleteMany: {
            args: Prisma.professorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.professorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.professorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professorPayload>
          }
          aggregate: {
            args: Prisma.ProfessorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfessor>
          }
          groupBy: {
            args: Prisma.professorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfessorGroupByOutputType>[]
          }
          count: {
            args: Prisma.professorCountArgs<ExtArgs>
            result: $Utils.Optional<ProfessorCountAggregateOutputType> | number
          }
        }
      }
      rota: {
        payload: Prisma.$rotaPayload<ExtArgs>
        fields: Prisma.rotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rotaPayload>
          }
          findFirst: {
            args: Prisma.rotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rotaPayload>
          }
          findMany: {
            args: Prisma.rotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rotaPayload>[]
          }
          create: {
            args: Prisma.rotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rotaPayload>
          }
          createMany: {
            args: Prisma.rotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rotaPayload>
          }
          update: {
            args: Prisma.rotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rotaPayload>
          }
          deleteMany: {
            args: Prisma.rotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rotaPayload>
          }
          aggregate: {
            args: Prisma.RotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRota>
          }
          groupBy: {
            args: Prisma.rotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<RotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.rotaCountArgs<ExtArgs>
            result: $Utils.Optional<RotaCountAggregateOutputType> | number
          }
        }
      }
      turma: {
        payload: Prisma.$turmaPayload<ExtArgs>
        fields: Prisma.turmaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.turmaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$turmaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.turmaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$turmaPayload>
          }
          findFirst: {
            args: Prisma.turmaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$turmaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.turmaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$turmaPayload>
          }
          findMany: {
            args: Prisma.turmaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$turmaPayload>[]
          }
          create: {
            args: Prisma.turmaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$turmaPayload>
          }
          createMany: {
            args: Prisma.turmaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.turmaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$turmaPayload>
          }
          update: {
            args: Prisma.turmaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$turmaPayload>
          }
          deleteMany: {
            args: Prisma.turmaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.turmaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.turmaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$turmaPayload>
          }
          aggregate: {
            args: Prisma.TurmaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTurma>
          }
          groupBy: {
            args: Prisma.turmaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TurmaGroupByOutputType>[]
          }
          count: {
            args: Prisma.turmaCountArgs<ExtArgs>
            result: $Utils.Optional<TurmaCountAggregateOutputType> | number
          }
        }
      }
      usuario: {
        payload: Prisma.$usuarioPayload<ExtArgs>
        fields: Prisma.usuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          findFirst: {
            args: Prisma.usuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          findMany: {
            args: Prisma.usuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[]
          }
          create: {
            args: Prisma.usuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          createMany: {
            args: Prisma.usuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          update: {
            args: Prisma.usuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          deleteMany: {
            args: Prisma.usuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.usuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AlunoCountOutputType
   */

  export type AlunoCountOutputType = {
    feito: number
  }

  export type AlunoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feito?: boolean | AlunoCountOutputTypeCountFeitoArgs
  }

  // Custom InputTypes
  /**
   * AlunoCountOutputType without action
   */
  export type AlunoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlunoCountOutputType
     */
    select?: AlunoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlunoCountOutputType without action
   */
  export type AlunoCountOutputTypeCountFeitoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feitoWhereInput
  }


  /**
   * Count Type AulaCountOutputType
   */

  export type AulaCountOutputType = {
    feito: number
  }

  export type AulaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feito?: boolean | AulaCountOutputTypeCountFeitoArgs
  }

  // Custom InputTypes
  /**
   * AulaCountOutputType without action
   */
  export type AulaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AulaCountOutputType
     */
    select?: AulaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AulaCountOutputType without action
   */
  export type AulaCountOutputTypeCountFeitoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feitoWhereInput
  }


  /**
   * Count Type GrupoCountOutputType
   */

  export type GrupoCountOutputType = {
    permissoes: number
    usuario: number
  }

  export type GrupoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissoes?: boolean | GrupoCountOutputTypeCountPermissoesArgs
    usuario?: boolean | GrupoCountOutputTypeCountUsuarioArgs
  }

  // Custom InputTypes
  /**
   * GrupoCountOutputType without action
   */
  export type GrupoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrupoCountOutputType
     */
    select?: GrupoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GrupoCountOutputType without action
   */
  export type GrupoCountOutputTypeCountPermissoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissoesWhereInput
  }

  /**
   * GrupoCountOutputType without action
   */
  export type GrupoCountOutputTypeCountUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuarioWhereInput
  }


  /**
   * Count Type ModuloCountOutputType
   */

  export type ModuloCountOutputType = {
    aula: number
  }

  export type ModuloCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aula?: boolean | ModuloCountOutputTypeCountAulaArgs
  }

  // Custom InputTypes
  /**
   * ModuloCountOutputType without action
   */
  export type ModuloCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloCountOutputType
     */
    select?: ModuloCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuloCountOutputType without action
   */
  export type ModuloCountOutputTypeCountAulaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aulaWhereInput
  }


  /**
   * Count Type RotaCountOutputType
   */

  export type RotaCountOutputType = {
    permissoes: number
  }

  export type RotaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissoes?: boolean | RotaCountOutputTypeCountPermissoesArgs
  }

  // Custom InputTypes
  /**
   * RotaCountOutputType without action
   */
  export type RotaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RotaCountOutputType
     */
    select?: RotaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RotaCountOutputType without action
   */
  export type RotaCountOutputTypeCountPermissoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissoesWhereInput
  }


  /**
   * Count Type TurmaCountOutputType
   */

  export type TurmaCountOutputType = {
    aluno: number
    modulo: number
    professor: number
  }

  export type TurmaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aluno?: boolean | TurmaCountOutputTypeCountAlunoArgs
    modulo?: boolean | TurmaCountOutputTypeCountModuloArgs
    professor?: boolean | TurmaCountOutputTypeCountProfessorArgs
  }

  // Custom InputTypes
  /**
   * TurmaCountOutputType without action
   */
  export type TurmaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TurmaCountOutputType
     */
    select?: TurmaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TurmaCountOutputType without action
   */
  export type TurmaCountOutputTypeCountAlunoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alunoWhereInput
  }

  /**
   * TurmaCountOutputType without action
   */
  export type TurmaCountOutputTypeCountModuloArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: moduloWhereInput
  }

  /**
   * TurmaCountOutputType without action
   */
  export type TurmaCountOutputTypeCountProfessorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: professorWhereInput
  }


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    aluno: number
    professor: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aluno?: boolean | UsuarioCountOutputTypeCountAlunoArgs
    professor?: boolean | UsuarioCountOutputTypeCountProfessorArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountAlunoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alunoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountProfessorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: professorWhereInput
  }


  /**
   * Models
   */

  /**
   * Model aluno
   */

  export type AggregateAluno = {
    _count: AlunoCountAggregateOutputType | null
    _avg: AlunoAvgAggregateOutputType | null
    _sum: AlunoSumAggregateOutputType | null
    _min: AlunoMinAggregateOutputType | null
    _max: AlunoMaxAggregateOutputType | null
  }

  export type AlunoAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    turma_id: number | null
  }

  export type AlunoSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    turma_id: number | null
  }

  export type AlunoMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    turma_id: number | null
  }

  export type AlunoMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    turma_id: number | null
  }

  export type AlunoCountAggregateOutputType = {
    id: number
    usuario_id: number
    turma_id: number
    _all: number
  }


  export type AlunoAvgAggregateInputType = {
    id?: true
    usuario_id?: true
    turma_id?: true
  }

  export type AlunoSumAggregateInputType = {
    id?: true
    usuario_id?: true
    turma_id?: true
  }

  export type AlunoMinAggregateInputType = {
    id?: true
    usuario_id?: true
    turma_id?: true
  }

  export type AlunoMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    turma_id?: true
  }

  export type AlunoCountAggregateInputType = {
    id?: true
    usuario_id?: true
    turma_id?: true
    _all?: true
  }

  export type AlunoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aluno to aggregate.
     */
    where?: alunoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alunos to fetch.
     */
    orderBy?: alunoOrderByWithRelationInput | alunoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: alunoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alunos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned alunos
    **/
    _count?: true | AlunoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlunoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlunoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlunoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlunoMaxAggregateInputType
  }

  export type GetAlunoAggregateType<T extends AlunoAggregateArgs> = {
        [P in keyof T & keyof AggregateAluno]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAluno[P]>
      : GetScalarType<T[P], AggregateAluno[P]>
  }




  export type alunoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alunoWhereInput
    orderBy?: alunoOrderByWithAggregationInput | alunoOrderByWithAggregationInput[]
    by: AlunoScalarFieldEnum[] | AlunoScalarFieldEnum
    having?: alunoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlunoCountAggregateInputType | true
    _avg?: AlunoAvgAggregateInputType
    _sum?: AlunoSumAggregateInputType
    _min?: AlunoMinAggregateInputType
    _max?: AlunoMaxAggregateInputType
  }

  export type AlunoGroupByOutputType = {
    id: number
    usuario_id: number
    turma_id: number
    _count: AlunoCountAggregateOutputType | null
    _avg: AlunoAvgAggregateOutputType | null
    _sum: AlunoSumAggregateOutputType | null
    _min: AlunoMinAggregateOutputType | null
    _max: AlunoMaxAggregateOutputType | null
  }

  type GetAlunoGroupByPayload<T extends alunoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlunoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlunoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlunoGroupByOutputType[P]>
            : GetScalarType<T[P], AlunoGroupByOutputType[P]>
        }
      >
    >


  export type alunoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    turma_id?: boolean
    turma?: boolean | turmaDefaultArgs<ExtArgs>
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    feito?: boolean | aluno$feitoArgs<ExtArgs>
    _count?: boolean | AlunoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aluno"]>


  export type alunoSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    turma_id?: boolean
  }

  export type alunoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    turma?: boolean | turmaDefaultArgs<ExtArgs>
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    feito?: boolean | aluno$feitoArgs<ExtArgs>
    _count?: boolean | AlunoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $alunoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "aluno"
    objects: {
      turma: Prisma.$turmaPayload<ExtArgs>
      usuario: Prisma.$usuarioPayload<ExtArgs>
      feito: Prisma.$feitoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      turma_id: number
    }, ExtArgs["result"]["aluno"]>
    composites: {}
  }

  type alunoGetPayload<S extends boolean | null | undefined | alunoDefaultArgs> = $Result.GetResult<Prisma.$alunoPayload, S>

  type alunoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<alunoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlunoCountAggregateInputType | true
    }

  export interface alunoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['aluno'], meta: { name: 'aluno' } }
    /**
     * Find zero or one Aluno that matches the filter.
     * @param {alunoFindUniqueArgs} args - Arguments to find a Aluno
     * @example
     * // Get one Aluno
     * const aluno = await prisma.aluno.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends alunoFindUniqueArgs>(args: SelectSubset<T, alunoFindUniqueArgs<ExtArgs>>): Prisma__alunoClient<$Result.GetResult<Prisma.$alunoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Aluno that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {alunoFindUniqueOrThrowArgs} args - Arguments to find a Aluno
     * @example
     * // Get one Aluno
     * const aluno = await prisma.aluno.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends alunoFindUniqueOrThrowArgs>(args: SelectSubset<T, alunoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__alunoClient<$Result.GetResult<Prisma.$alunoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Aluno that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alunoFindFirstArgs} args - Arguments to find a Aluno
     * @example
     * // Get one Aluno
     * const aluno = await prisma.aluno.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends alunoFindFirstArgs>(args?: SelectSubset<T, alunoFindFirstArgs<ExtArgs>>): Prisma__alunoClient<$Result.GetResult<Prisma.$alunoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Aluno that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alunoFindFirstOrThrowArgs} args - Arguments to find a Aluno
     * @example
     * // Get one Aluno
     * const aluno = await prisma.aluno.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends alunoFindFirstOrThrowArgs>(args?: SelectSubset<T, alunoFindFirstOrThrowArgs<ExtArgs>>): Prisma__alunoClient<$Result.GetResult<Prisma.$alunoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alunos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alunoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alunos
     * const alunos = await prisma.aluno.findMany()
     * 
     * // Get first 10 Alunos
     * const alunos = await prisma.aluno.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alunoWithIdOnly = await prisma.aluno.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends alunoFindManyArgs>(args?: SelectSubset<T, alunoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alunoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Aluno.
     * @param {alunoCreateArgs} args - Arguments to create a Aluno.
     * @example
     * // Create one Aluno
     * const Aluno = await prisma.aluno.create({
     *   data: {
     *     // ... data to create a Aluno
     *   }
     * })
     * 
     */
    create<T extends alunoCreateArgs>(args: SelectSubset<T, alunoCreateArgs<ExtArgs>>): Prisma__alunoClient<$Result.GetResult<Prisma.$alunoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alunos.
     * @param {alunoCreateManyArgs} args - Arguments to create many Alunos.
     * @example
     * // Create many Alunos
     * const aluno = await prisma.aluno.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends alunoCreateManyArgs>(args?: SelectSubset<T, alunoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Aluno.
     * @param {alunoDeleteArgs} args - Arguments to delete one Aluno.
     * @example
     * // Delete one Aluno
     * const Aluno = await prisma.aluno.delete({
     *   where: {
     *     // ... filter to delete one Aluno
     *   }
     * })
     * 
     */
    delete<T extends alunoDeleteArgs>(args: SelectSubset<T, alunoDeleteArgs<ExtArgs>>): Prisma__alunoClient<$Result.GetResult<Prisma.$alunoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Aluno.
     * @param {alunoUpdateArgs} args - Arguments to update one Aluno.
     * @example
     * // Update one Aluno
     * const aluno = await prisma.aluno.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends alunoUpdateArgs>(args: SelectSubset<T, alunoUpdateArgs<ExtArgs>>): Prisma__alunoClient<$Result.GetResult<Prisma.$alunoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alunos.
     * @param {alunoDeleteManyArgs} args - Arguments to filter Alunos to delete.
     * @example
     * // Delete a few Alunos
     * const { count } = await prisma.aluno.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends alunoDeleteManyArgs>(args?: SelectSubset<T, alunoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alunos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alunoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alunos
     * const aluno = await prisma.aluno.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends alunoUpdateManyArgs>(args: SelectSubset<T, alunoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Aluno.
     * @param {alunoUpsertArgs} args - Arguments to update or create a Aluno.
     * @example
     * // Update or create a Aluno
     * const aluno = await prisma.aluno.upsert({
     *   create: {
     *     // ... data to create a Aluno
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aluno we want to update
     *   }
     * })
     */
    upsert<T extends alunoUpsertArgs>(args: SelectSubset<T, alunoUpsertArgs<ExtArgs>>): Prisma__alunoClient<$Result.GetResult<Prisma.$alunoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alunos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alunoCountArgs} args - Arguments to filter Alunos to count.
     * @example
     * // Count the number of Alunos
     * const count = await prisma.aluno.count({
     *   where: {
     *     // ... the filter for the Alunos we want to count
     *   }
     * })
    **/
    count<T extends alunoCountArgs>(
      args?: Subset<T, alunoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlunoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aluno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlunoAggregateArgs>(args: Subset<T, AlunoAggregateArgs>): Prisma.PrismaPromise<GetAlunoAggregateType<T>>

    /**
     * Group by Aluno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alunoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends alunoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: alunoGroupByArgs['orderBy'] }
        : { orderBy?: alunoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, alunoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlunoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the aluno model
   */
  readonly fields: alunoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for aluno.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__alunoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    turma<T extends turmaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, turmaDefaultArgs<ExtArgs>>): Prisma__turmaClient<$Result.GetResult<Prisma.$turmaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends usuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuarioDefaultArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    feito<T extends aluno$feitoArgs<ExtArgs> = {}>(args?: Subset<T, aluno$feitoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feitoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the aluno model
   */ 
  interface alunoFieldRefs {
    readonly id: FieldRef<"aluno", 'Int'>
    readonly usuario_id: FieldRef<"aluno", 'Int'>
    readonly turma_id: FieldRef<"aluno", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * aluno findUnique
   */
  export type alunoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aluno
     */
    select?: alunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alunoInclude<ExtArgs> | null
    /**
     * Filter, which aluno to fetch.
     */
    where: alunoWhereUniqueInput
  }

  /**
   * aluno findUniqueOrThrow
   */
  export type alunoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aluno
     */
    select?: alunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alunoInclude<ExtArgs> | null
    /**
     * Filter, which aluno to fetch.
     */
    where: alunoWhereUniqueInput
  }

  /**
   * aluno findFirst
   */
  export type alunoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aluno
     */
    select?: alunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alunoInclude<ExtArgs> | null
    /**
     * Filter, which aluno to fetch.
     */
    where?: alunoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alunos to fetch.
     */
    orderBy?: alunoOrderByWithRelationInput | alunoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alunos.
     */
    cursor?: alunoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alunos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alunos.
     */
    distinct?: AlunoScalarFieldEnum | AlunoScalarFieldEnum[]
  }

  /**
   * aluno findFirstOrThrow
   */
  export type alunoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aluno
     */
    select?: alunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alunoInclude<ExtArgs> | null
    /**
     * Filter, which aluno to fetch.
     */
    where?: alunoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alunos to fetch.
     */
    orderBy?: alunoOrderByWithRelationInput | alunoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alunos.
     */
    cursor?: alunoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alunos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alunos.
     */
    distinct?: AlunoScalarFieldEnum | AlunoScalarFieldEnum[]
  }

  /**
   * aluno findMany
   */
  export type alunoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aluno
     */
    select?: alunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alunoInclude<ExtArgs> | null
    /**
     * Filter, which alunos to fetch.
     */
    where?: alunoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alunos to fetch.
     */
    orderBy?: alunoOrderByWithRelationInput | alunoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing alunos.
     */
    cursor?: alunoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alunos.
     */
    skip?: number
    distinct?: AlunoScalarFieldEnum | AlunoScalarFieldEnum[]
  }

  /**
   * aluno create
   */
  export type alunoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aluno
     */
    select?: alunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alunoInclude<ExtArgs> | null
    /**
     * The data needed to create a aluno.
     */
    data: XOR<alunoCreateInput, alunoUncheckedCreateInput>
  }

  /**
   * aluno createMany
   */
  export type alunoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many alunos.
     */
    data: alunoCreateManyInput | alunoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * aluno update
   */
  export type alunoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aluno
     */
    select?: alunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alunoInclude<ExtArgs> | null
    /**
     * The data needed to update a aluno.
     */
    data: XOR<alunoUpdateInput, alunoUncheckedUpdateInput>
    /**
     * Choose, which aluno to update.
     */
    where: alunoWhereUniqueInput
  }

  /**
   * aluno updateMany
   */
  export type alunoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update alunos.
     */
    data: XOR<alunoUpdateManyMutationInput, alunoUncheckedUpdateManyInput>
    /**
     * Filter which alunos to update
     */
    where?: alunoWhereInput
  }

  /**
   * aluno upsert
   */
  export type alunoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aluno
     */
    select?: alunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alunoInclude<ExtArgs> | null
    /**
     * The filter to search for the aluno to update in case it exists.
     */
    where: alunoWhereUniqueInput
    /**
     * In case the aluno found by the `where` argument doesn't exist, create a new aluno with this data.
     */
    create: XOR<alunoCreateInput, alunoUncheckedCreateInput>
    /**
     * In case the aluno was found with the provided `where` argument, update it with this data.
     */
    update: XOR<alunoUpdateInput, alunoUncheckedUpdateInput>
  }

  /**
   * aluno delete
   */
  export type alunoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aluno
     */
    select?: alunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alunoInclude<ExtArgs> | null
    /**
     * Filter which aluno to delete.
     */
    where: alunoWhereUniqueInput
  }

  /**
   * aluno deleteMany
   */
  export type alunoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alunos to delete
     */
    where?: alunoWhereInput
  }

  /**
   * aluno.feito
   */
  export type aluno$feitoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feito
     */
    select?: feitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feitoInclude<ExtArgs> | null
    where?: feitoWhereInput
    orderBy?: feitoOrderByWithRelationInput | feitoOrderByWithRelationInput[]
    cursor?: feitoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeitoScalarFieldEnum | FeitoScalarFieldEnum[]
  }

  /**
   * aluno without action
   */
  export type alunoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aluno
     */
    select?: alunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alunoInclude<ExtArgs> | null
  }


  /**
   * Model aula
   */

  export type AggregateAula = {
    _count: AulaCountAggregateOutputType | null
    _avg: AulaAvgAggregateOutputType | null
    _sum: AulaSumAggregateOutputType | null
    _min: AulaMinAggregateOutputType | null
    _max: AulaMaxAggregateOutputType | null
  }

  export type AulaAvgAggregateOutputType = {
    id: number | null
    modulo_id: number | null
  }

  export type AulaSumAggregateOutputType = {
    id: number | null
    modulo_id: number | null
  }

  export type AulaMinAggregateOutputType = {
    id: number | null
    modulo_id: number | null
    titulo: string | null
    video: string | null
    pdf_questoes: string | null
    pdf_resolucao: string | null
    descricao: string | null
  }

  export type AulaMaxAggregateOutputType = {
    id: number | null
    modulo_id: number | null
    titulo: string | null
    video: string | null
    pdf_questoes: string | null
    pdf_resolucao: string | null
    descricao: string | null
  }

  export type AulaCountAggregateOutputType = {
    id: number
    modulo_id: number
    titulo: number
    video: number
    pdf_questoes: number
    pdf_resolucao: number
    descricao: number
    _all: number
  }


  export type AulaAvgAggregateInputType = {
    id?: true
    modulo_id?: true
  }

  export type AulaSumAggregateInputType = {
    id?: true
    modulo_id?: true
  }

  export type AulaMinAggregateInputType = {
    id?: true
    modulo_id?: true
    titulo?: true
    video?: true
    pdf_questoes?: true
    pdf_resolucao?: true
    descricao?: true
  }

  export type AulaMaxAggregateInputType = {
    id?: true
    modulo_id?: true
    titulo?: true
    video?: true
    pdf_questoes?: true
    pdf_resolucao?: true
    descricao?: true
  }

  export type AulaCountAggregateInputType = {
    id?: true
    modulo_id?: true
    titulo?: true
    video?: true
    pdf_questoes?: true
    pdf_resolucao?: true
    descricao?: true
    _all?: true
  }

  export type AulaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aula to aggregate.
     */
    where?: aulaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aulas to fetch.
     */
    orderBy?: aulaOrderByWithRelationInput | aulaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: aulaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aulas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aulas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned aulas
    **/
    _count?: true | AulaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AulaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AulaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AulaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AulaMaxAggregateInputType
  }

  export type GetAulaAggregateType<T extends AulaAggregateArgs> = {
        [P in keyof T & keyof AggregateAula]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAula[P]>
      : GetScalarType<T[P], AggregateAula[P]>
  }




  export type aulaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aulaWhereInput
    orderBy?: aulaOrderByWithAggregationInput | aulaOrderByWithAggregationInput[]
    by: AulaScalarFieldEnum[] | AulaScalarFieldEnum
    having?: aulaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AulaCountAggregateInputType | true
    _avg?: AulaAvgAggregateInputType
    _sum?: AulaSumAggregateInputType
    _min?: AulaMinAggregateInputType
    _max?: AulaMaxAggregateInputType
  }

  export type AulaGroupByOutputType = {
    id: number
    modulo_id: number
    titulo: string | null
    video: string
    pdf_questoes: string | null
    pdf_resolucao: string | null
    descricao: string | null
    _count: AulaCountAggregateOutputType | null
    _avg: AulaAvgAggregateOutputType | null
    _sum: AulaSumAggregateOutputType | null
    _min: AulaMinAggregateOutputType | null
    _max: AulaMaxAggregateOutputType | null
  }

  type GetAulaGroupByPayload<T extends aulaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AulaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AulaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AulaGroupByOutputType[P]>
            : GetScalarType<T[P], AulaGroupByOutputType[P]>
        }
      >
    >


  export type aulaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modulo_id?: boolean
    titulo?: boolean
    video?: boolean
    pdf_questoes?: boolean
    pdf_resolucao?: boolean
    descricao?: boolean
    modulo?: boolean | moduloDefaultArgs<ExtArgs>
    feito?: boolean | aula$feitoArgs<ExtArgs>
    _count?: boolean | AulaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aula"]>


  export type aulaSelectScalar = {
    id?: boolean
    modulo_id?: boolean
    titulo?: boolean
    video?: boolean
    pdf_questoes?: boolean
    pdf_resolucao?: boolean
    descricao?: boolean
  }

  export type aulaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modulo?: boolean | moduloDefaultArgs<ExtArgs>
    feito?: boolean | aula$feitoArgs<ExtArgs>
    _count?: boolean | AulaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $aulaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "aula"
    objects: {
      modulo: Prisma.$moduloPayload<ExtArgs>
      feito: Prisma.$feitoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      modulo_id: number
      titulo: string | null
      video: string
      pdf_questoes: string | null
      pdf_resolucao: string | null
      descricao: string | null
    }, ExtArgs["result"]["aula"]>
    composites: {}
  }

  type aulaGetPayload<S extends boolean | null | undefined | aulaDefaultArgs> = $Result.GetResult<Prisma.$aulaPayload, S>

  type aulaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<aulaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AulaCountAggregateInputType | true
    }

  export interface aulaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['aula'], meta: { name: 'aula' } }
    /**
     * Find zero or one Aula that matches the filter.
     * @param {aulaFindUniqueArgs} args - Arguments to find a Aula
     * @example
     * // Get one Aula
     * const aula = await prisma.aula.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends aulaFindUniqueArgs>(args: SelectSubset<T, aulaFindUniqueArgs<ExtArgs>>): Prisma__aulaClient<$Result.GetResult<Prisma.$aulaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Aula that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {aulaFindUniqueOrThrowArgs} args - Arguments to find a Aula
     * @example
     * // Get one Aula
     * const aula = await prisma.aula.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends aulaFindUniqueOrThrowArgs>(args: SelectSubset<T, aulaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__aulaClient<$Result.GetResult<Prisma.$aulaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Aula that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aulaFindFirstArgs} args - Arguments to find a Aula
     * @example
     * // Get one Aula
     * const aula = await prisma.aula.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends aulaFindFirstArgs>(args?: SelectSubset<T, aulaFindFirstArgs<ExtArgs>>): Prisma__aulaClient<$Result.GetResult<Prisma.$aulaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Aula that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aulaFindFirstOrThrowArgs} args - Arguments to find a Aula
     * @example
     * // Get one Aula
     * const aula = await prisma.aula.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends aulaFindFirstOrThrowArgs>(args?: SelectSubset<T, aulaFindFirstOrThrowArgs<ExtArgs>>): Prisma__aulaClient<$Result.GetResult<Prisma.$aulaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Aulas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aulaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Aulas
     * const aulas = await prisma.aula.findMany()
     * 
     * // Get first 10 Aulas
     * const aulas = await prisma.aula.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aulaWithIdOnly = await prisma.aula.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends aulaFindManyArgs>(args?: SelectSubset<T, aulaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aulaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Aula.
     * @param {aulaCreateArgs} args - Arguments to create a Aula.
     * @example
     * // Create one Aula
     * const Aula = await prisma.aula.create({
     *   data: {
     *     // ... data to create a Aula
     *   }
     * })
     * 
     */
    create<T extends aulaCreateArgs>(args: SelectSubset<T, aulaCreateArgs<ExtArgs>>): Prisma__aulaClient<$Result.GetResult<Prisma.$aulaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Aulas.
     * @param {aulaCreateManyArgs} args - Arguments to create many Aulas.
     * @example
     * // Create many Aulas
     * const aula = await prisma.aula.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends aulaCreateManyArgs>(args?: SelectSubset<T, aulaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Aula.
     * @param {aulaDeleteArgs} args - Arguments to delete one Aula.
     * @example
     * // Delete one Aula
     * const Aula = await prisma.aula.delete({
     *   where: {
     *     // ... filter to delete one Aula
     *   }
     * })
     * 
     */
    delete<T extends aulaDeleteArgs>(args: SelectSubset<T, aulaDeleteArgs<ExtArgs>>): Prisma__aulaClient<$Result.GetResult<Prisma.$aulaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Aula.
     * @param {aulaUpdateArgs} args - Arguments to update one Aula.
     * @example
     * // Update one Aula
     * const aula = await prisma.aula.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends aulaUpdateArgs>(args: SelectSubset<T, aulaUpdateArgs<ExtArgs>>): Prisma__aulaClient<$Result.GetResult<Prisma.$aulaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Aulas.
     * @param {aulaDeleteManyArgs} args - Arguments to filter Aulas to delete.
     * @example
     * // Delete a few Aulas
     * const { count } = await prisma.aula.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends aulaDeleteManyArgs>(args?: SelectSubset<T, aulaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aulas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aulaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Aulas
     * const aula = await prisma.aula.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends aulaUpdateManyArgs>(args: SelectSubset<T, aulaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Aula.
     * @param {aulaUpsertArgs} args - Arguments to update or create a Aula.
     * @example
     * // Update or create a Aula
     * const aula = await prisma.aula.upsert({
     *   create: {
     *     // ... data to create a Aula
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aula we want to update
     *   }
     * })
     */
    upsert<T extends aulaUpsertArgs>(args: SelectSubset<T, aulaUpsertArgs<ExtArgs>>): Prisma__aulaClient<$Result.GetResult<Prisma.$aulaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Aulas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aulaCountArgs} args - Arguments to filter Aulas to count.
     * @example
     * // Count the number of Aulas
     * const count = await prisma.aula.count({
     *   where: {
     *     // ... the filter for the Aulas we want to count
     *   }
     * })
    **/
    count<T extends aulaCountArgs>(
      args?: Subset<T, aulaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AulaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aula.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AulaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AulaAggregateArgs>(args: Subset<T, AulaAggregateArgs>): Prisma.PrismaPromise<GetAulaAggregateType<T>>

    /**
     * Group by Aula.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aulaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends aulaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: aulaGroupByArgs['orderBy'] }
        : { orderBy?: aulaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, aulaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAulaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the aula model
   */
  readonly fields: aulaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for aula.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__aulaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modulo<T extends moduloDefaultArgs<ExtArgs> = {}>(args?: Subset<T, moduloDefaultArgs<ExtArgs>>): Prisma__moduloClient<$Result.GetResult<Prisma.$moduloPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    feito<T extends aula$feitoArgs<ExtArgs> = {}>(args?: Subset<T, aula$feitoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feitoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the aula model
   */ 
  interface aulaFieldRefs {
    readonly id: FieldRef<"aula", 'Int'>
    readonly modulo_id: FieldRef<"aula", 'Int'>
    readonly titulo: FieldRef<"aula", 'String'>
    readonly video: FieldRef<"aula", 'String'>
    readonly pdf_questoes: FieldRef<"aula", 'String'>
    readonly pdf_resolucao: FieldRef<"aula", 'String'>
    readonly descricao: FieldRef<"aula", 'String'>
  }
    

  // Custom InputTypes
  /**
   * aula findUnique
   */
  export type aulaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aula
     */
    select?: aulaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aulaInclude<ExtArgs> | null
    /**
     * Filter, which aula to fetch.
     */
    where: aulaWhereUniqueInput
  }

  /**
   * aula findUniqueOrThrow
   */
  export type aulaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aula
     */
    select?: aulaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aulaInclude<ExtArgs> | null
    /**
     * Filter, which aula to fetch.
     */
    where: aulaWhereUniqueInput
  }

  /**
   * aula findFirst
   */
  export type aulaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aula
     */
    select?: aulaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aulaInclude<ExtArgs> | null
    /**
     * Filter, which aula to fetch.
     */
    where?: aulaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aulas to fetch.
     */
    orderBy?: aulaOrderByWithRelationInput | aulaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aulas.
     */
    cursor?: aulaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aulas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aulas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aulas.
     */
    distinct?: AulaScalarFieldEnum | AulaScalarFieldEnum[]
  }

  /**
   * aula findFirstOrThrow
   */
  export type aulaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aula
     */
    select?: aulaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aulaInclude<ExtArgs> | null
    /**
     * Filter, which aula to fetch.
     */
    where?: aulaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aulas to fetch.
     */
    orderBy?: aulaOrderByWithRelationInput | aulaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aulas.
     */
    cursor?: aulaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aulas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aulas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aulas.
     */
    distinct?: AulaScalarFieldEnum | AulaScalarFieldEnum[]
  }

  /**
   * aula findMany
   */
  export type aulaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aula
     */
    select?: aulaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aulaInclude<ExtArgs> | null
    /**
     * Filter, which aulas to fetch.
     */
    where?: aulaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aulas to fetch.
     */
    orderBy?: aulaOrderByWithRelationInput | aulaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing aulas.
     */
    cursor?: aulaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aulas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aulas.
     */
    skip?: number
    distinct?: AulaScalarFieldEnum | AulaScalarFieldEnum[]
  }

  /**
   * aula create
   */
  export type aulaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aula
     */
    select?: aulaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aulaInclude<ExtArgs> | null
    /**
     * The data needed to create a aula.
     */
    data: XOR<aulaCreateInput, aulaUncheckedCreateInput>
  }

  /**
   * aula createMany
   */
  export type aulaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many aulas.
     */
    data: aulaCreateManyInput | aulaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * aula update
   */
  export type aulaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aula
     */
    select?: aulaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aulaInclude<ExtArgs> | null
    /**
     * The data needed to update a aula.
     */
    data: XOR<aulaUpdateInput, aulaUncheckedUpdateInput>
    /**
     * Choose, which aula to update.
     */
    where: aulaWhereUniqueInput
  }

  /**
   * aula updateMany
   */
  export type aulaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update aulas.
     */
    data: XOR<aulaUpdateManyMutationInput, aulaUncheckedUpdateManyInput>
    /**
     * Filter which aulas to update
     */
    where?: aulaWhereInput
  }

  /**
   * aula upsert
   */
  export type aulaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aula
     */
    select?: aulaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aulaInclude<ExtArgs> | null
    /**
     * The filter to search for the aula to update in case it exists.
     */
    where: aulaWhereUniqueInput
    /**
     * In case the aula found by the `where` argument doesn't exist, create a new aula with this data.
     */
    create: XOR<aulaCreateInput, aulaUncheckedCreateInput>
    /**
     * In case the aula was found with the provided `where` argument, update it with this data.
     */
    update: XOR<aulaUpdateInput, aulaUncheckedUpdateInput>
  }

  /**
   * aula delete
   */
  export type aulaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aula
     */
    select?: aulaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aulaInclude<ExtArgs> | null
    /**
     * Filter which aula to delete.
     */
    where: aulaWhereUniqueInput
  }

  /**
   * aula deleteMany
   */
  export type aulaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aulas to delete
     */
    where?: aulaWhereInput
  }

  /**
   * aula.feito
   */
  export type aula$feitoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feito
     */
    select?: feitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feitoInclude<ExtArgs> | null
    where?: feitoWhereInput
    orderBy?: feitoOrderByWithRelationInput | feitoOrderByWithRelationInput[]
    cursor?: feitoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeitoScalarFieldEnum | FeitoScalarFieldEnum[]
  }

  /**
   * aula without action
   */
  export type aulaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aula
     */
    select?: aulaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aulaInclude<ExtArgs> | null
  }


  /**
   * Model feito
   */

  export type AggregateFeito = {
    _count: FeitoCountAggregateOutputType | null
    _avg: FeitoAvgAggregateOutputType | null
    _sum: FeitoSumAggregateOutputType | null
    _min: FeitoMinAggregateOutputType | null
    _max: FeitoMaxAggregateOutputType | null
  }

  export type FeitoAvgAggregateOutputType = {
    id: number | null
    aula_id: number | null
    aluno_id: number | null
  }

  export type FeitoSumAggregateOutputType = {
    id: number | null
    aula_id: number | null
    aluno_id: number | null
  }

  export type FeitoMinAggregateOutputType = {
    id: number | null
    feito: boolean | null
    revisar: boolean | null
    aula_id: number | null
    aluno_id: number | null
  }

  export type FeitoMaxAggregateOutputType = {
    id: number | null
    feito: boolean | null
    revisar: boolean | null
    aula_id: number | null
    aluno_id: number | null
  }

  export type FeitoCountAggregateOutputType = {
    id: number
    feito: number
    revisar: number
    aula_id: number
    aluno_id: number
    _all: number
  }


  export type FeitoAvgAggregateInputType = {
    id?: true
    aula_id?: true
    aluno_id?: true
  }

  export type FeitoSumAggregateInputType = {
    id?: true
    aula_id?: true
    aluno_id?: true
  }

  export type FeitoMinAggregateInputType = {
    id?: true
    feito?: true
    revisar?: true
    aula_id?: true
    aluno_id?: true
  }

  export type FeitoMaxAggregateInputType = {
    id?: true
    feito?: true
    revisar?: true
    aula_id?: true
    aluno_id?: true
  }

  export type FeitoCountAggregateInputType = {
    id?: true
    feito?: true
    revisar?: true
    aula_id?: true
    aluno_id?: true
    _all?: true
  }

  export type FeitoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feito to aggregate.
     */
    where?: feitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feitos to fetch.
     */
    orderBy?: feitoOrderByWithRelationInput | feitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: feitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned feitos
    **/
    _count?: true | FeitoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeitoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeitoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeitoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeitoMaxAggregateInputType
  }

  export type GetFeitoAggregateType<T extends FeitoAggregateArgs> = {
        [P in keyof T & keyof AggregateFeito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeito[P]>
      : GetScalarType<T[P], AggregateFeito[P]>
  }




  export type feitoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feitoWhereInput
    orderBy?: feitoOrderByWithAggregationInput | feitoOrderByWithAggregationInput[]
    by: FeitoScalarFieldEnum[] | FeitoScalarFieldEnum
    having?: feitoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeitoCountAggregateInputType | true
    _avg?: FeitoAvgAggregateInputType
    _sum?: FeitoSumAggregateInputType
    _min?: FeitoMinAggregateInputType
    _max?: FeitoMaxAggregateInputType
  }

  export type FeitoGroupByOutputType = {
    id: number
    feito: boolean | null
    revisar: boolean | null
    aula_id: number
    aluno_id: number
    _count: FeitoCountAggregateOutputType | null
    _avg: FeitoAvgAggregateOutputType | null
    _sum: FeitoSumAggregateOutputType | null
    _min: FeitoMinAggregateOutputType | null
    _max: FeitoMaxAggregateOutputType | null
  }

  type GetFeitoGroupByPayload<T extends feitoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeitoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeitoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeitoGroupByOutputType[P]>
            : GetScalarType<T[P], FeitoGroupByOutputType[P]>
        }
      >
    >


  export type feitoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feito?: boolean
    revisar?: boolean
    aula_id?: boolean
    aluno_id?: boolean
    aluno?: boolean | alunoDefaultArgs<ExtArgs>
    aula?: boolean | aulaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feito"]>


  export type feitoSelectScalar = {
    id?: boolean
    feito?: boolean
    revisar?: boolean
    aula_id?: boolean
    aluno_id?: boolean
  }

  export type feitoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aluno?: boolean | alunoDefaultArgs<ExtArgs>
    aula?: boolean | aulaDefaultArgs<ExtArgs>
  }

  export type $feitoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "feito"
    objects: {
      aluno: Prisma.$alunoPayload<ExtArgs>
      aula: Prisma.$aulaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      feito: boolean | null
      revisar: boolean | null
      aula_id: number
      aluno_id: number
    }, ExtArgs["result"]["feito"]>
    composites: {}
  }

  type feitoGetPayload<S extends boolean | null | undefined | feitoDefaultArgs> = $Result.GetResult<Prisma.$feitoPayload, S>

  type feitoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<feitoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeitoCountAggregateInputType | true
    }

  export interface feitoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['feito'], meta: { name: 'feito' } }
    /**
     * Find zero or one Feito that matches the filter.
     * @param {feitoFindUniqueArgs} args - Arguments to find a Feito
     * @example
     * // Get one Feito
     * const feito = await prisma.feito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends feitoFindUniqueArgs>(args: SelectSubset<T, feitoFindUniqueArgs<ExtArgs>>): Prisma__feitoClient<$Result.GetResult<Prisma.$feitoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Feito that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {feitoFindUniqueOrThrowArgs} args - Arguments to find a Feito
     * @example
     * // Get one Feito
     * const feito = await prisma.feito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends feitoFindUniqueOrThrowArgs>(args: SelectSubset<T, feitoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__feitoClient<$Result.GetResult<Prisma.$feitoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Feito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feitoFindFirstArgs} args - Arguments to find a Feito
     * @example
     * // Get one Feito
     * const feito = await prisma.feito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends feitoFindFirstArgs>(args?: SelectSubset<T, feitoFindFirstArgs<ExtArgs>>): Prisma__feitoClient<$Result.GetResult<Prisma.$feitoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Feito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feitoFindFirstOrThrowArgs} args - Arguments to find a Feito
     * @example
     * // Get one Feito
     * const feito = await prisma.feito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends feitoFindFirstOrThrowArgs>(args?: SelectSubset<T, feitoFindFirstOrThrowArgs<ExtArgs>>): Prisma__feitoClient<$Result.GetResult<Prisma.$feitoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Feitos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feitoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feitos
     * const feitos = await prisma.feito.findMany()
     * 
     * // Get first 10 Feitos
     * const feitos = await prisma.feito.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feitoWithIdOnly = await prisma.feito.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends feitoFindManyArgs>(args?: SelectSubset<T, feitoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feitoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Feito.
     * @param {feitoCreateArgs} args - Arguments to create a Feito.
     * @example
     * // Create one Feito
     * const Feito = await prisma.feito.create({
     *   data: {
     *     // ... data to create a Feito
     *   }
     * })
     * 
     */
    create<T extends feitoCreateArgs>(args: SelectSubset<T, feitoCreateArgs<ExtArgs>>): Prisma__feitoClient<$Result.GetResult<Prisma.$feitoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Feitos.
     * @param {feitoCreateManyArgs} args - Arguments to create many Feitos.
     * @example
     * // Create many Feitos
     * const feito = await prisma.feito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends feitoCreateManyArgs>(args?: SelectSubset<T, feitoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Feito.
     * @param {feitoDeleteArgs} args - Arguments to delete one Feito.
     * @example
     * // Delete one Feito
     * const Feito = await prisma.feito.delete({
     *   where: {
     *     // ... filter to delete one Feito
     *   }
     * })
     * 
     */
    delete<T extends feitoDeleteArgs>(args: SelectSubset<T, feitoDeleteArgs<ExtArgs>>): Prisma__feitoClient<$Result.GetResult<Prisma.$feitoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Feito.
     * @param {feitoUpdateArgs} args - Arguments to update one Feito.
     * @example
     * // Update one Feito
     * const feito = await prisma.feito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends feitoUpdateArgs>(args: SelectSubset<T, feitoUpdateArgs<ExtArgs>>): Prisma__feitoClient<$Result.GetResult<Prisma.$feitoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Feitos.
     * @param {feitoDeleteManyArgs} args - Arguments to filter Feitos to delete.
     * @example
     * // Delete a few Feitos
     * const { count } = await prisma.feito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends feitoDeleteManyArgs>(args?: SelectSubset<T, feitoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feitoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feitos
     * const feito = await prisma.feito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends feitoUpdateManyArgs>(args: SelectSubset<T, feitoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feito.
     * @param {feitoUpsertArgs} args - Arguments to update or create a Feito.
     * @example
     * // Update or create a Feito
     * const feito = await prisma.feito.upsert({
     *   create: {
     *     // ... data to create a Feito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feito we want to update
     *   }
     * })
     */
    upsert<T extends feitoUpsertArgs>(args: SelectSubset<T, feitoUpsertArgs<ExtArgs>>): Prisma__feitoClient<$Result.GetResult<Prisma.$feitoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Feitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feitoCountArgs} args - Arguments to filter Feitos to count.
     * @example
     * // Count the number of Feitos
     * const count = await prisma.feito.count({
     *   where: {
     *     // ... the filter for the Feitos we want to count
     *   }
     * })
    **/
    count<T extends feitoCountArgs>(
      args?: Subset<T, feitoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeitoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeitoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeitoAggregateArgs>(args: Subset<T, FeitoAggregateArgs>): Prisma.PrismaPromise<GetFeitoAggregateType<T>>

    /**
     * Group by Feito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feitoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends feitoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: feitoGroupByArgs['orderBy'] }
        : { orderBy?: feitoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, feitoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeitoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the feito model
   */
  readonly fields: feitoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for feito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__feitoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aluno<T extends alunoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, alunoDefaultArgs<ExtArgs>>): Prisma__alunoClient<$Result.GetResult<Prisma.$alunoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    aula<T extends aulaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, aulaDefaultArgs<ExtArgs>>): Prisma__aulaClient<$Result.GetResult<Prisma.$aulaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the feito model
   */ 
  interface feitoFieldRefs {
    readonly id: FieldRef<"feito", 'Int'>
    readonly feito: FieldRef<"feito", 'Boolean'>
    readonly revisar: FieldRef<"feito", 'Boolean'>
    readonly aula_id: FieldRef<"feito", 'Int'>
    readonly aluno_id: FieldRef<"feito", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * feito findUnique
   */
  export type feitoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feito
     */
    select?: feitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feitoInclude<ExtArgs> | null
    /**
     * Filter, which feito to fetch.
     */
    where: feitoWhereUniqueInput
  }

  /**
   * feito findUniqueOrThrow
   */
  export type feitoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feito
     */
    select?: feitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feitoInclude<ExtArgs> | null
    /**
     * Filter, which feito to fetch.
     */
    where: feitoWhereUniqueInput
  }

  /**
   * feito findFirst
   */
  export type feitoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feito
     */
    select?: feitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feitoInclude<ExtArgs> | null
    /**
     * Filter, which feito to fetch.
     */
    where?: feitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feitos to fetch.
     */
    orderBy?: feitoOrderByWithRelationInput | feitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feitos.
     */
    cursor?: feitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feitos.
     */
    distinct?: FeitoScalarFieldEnum | FeitoScalarFieldEnum[]
  }

  /**
   * feito findFirstOrThrow
   */
  export type feitoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feito
     */
    select?: feitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feitoInclude<ExtArgs> | null
    /**
     * Filter, which feito to fetch.
     */
    where?: feitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feitos to fetch.
     */
    orderBy?: feitoOrderByWithRelationInput | feitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feitos.
     */
    cursor?: feitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feitos.
     */
    distinct?: FeitoScalarFieldEnum | FeitoScalarFieldEnum[]
  }

  /**
   * feito findMany
   */
  export type feitoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feito
     */
    select?: feitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feitoInclude<ExtArgs> | null
    /**
     * Filter, which feitos to fetch.
     */
    where?: feitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feitos to fetch.
     */
    orderBy?: feitoOrderByWithRelationInput | feitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing feitos.
     */
    cursor?: feitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feitos.
     */
    skip?: number
    distinct?: FeitoScalarFieldEnum | FeitoScalarFieldEnum[]
  }

  /**
   * feito create
   */
  export type feitoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feito
     */
    select?: feitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feitoInclude<ExtArgs> | null
    /**
     * The data needed to create a feito.
     */
    data: XOR<feitoCreateInput, feitoUncheckedCreateInput>
  }

  /**
   * feito createMany
   */
  export type feitoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many feitos.
     */
    data: feitoCreateManyInput | feitoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * feito update
   */
  export type feitoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feito
     */
    select?: feitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feitoInclude<ExtArgs> | null
    /**
     * The data needed to update a feito.
     */
    data: XOR<feitoUpdateInput, feitoUncheckedUpdateInput>
    /**
     * Choose, which feito to update.
     */
    where: feitoWhereUniqueInput
  }

  /**
   * feito updateMany
   */
  export type feitoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update feitos.
     */
    data: XOR<feitoUpdateManyMutationInput, feitoUncheckedUpdateManyInput>
    /**
     * Filter which feitos to update
     */
    where?: feitoWhereInput
  }

  /**
   * feito upsert
   */
  export type feitoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feito
     */
    select?: feitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feitoInclude<ExtArgs> | null
    /**
     * The filter to search for the feito to update in case it exists.
     */
    where: feitoWhereUniqueInput
    /**
     * In case the feito found by the `where` argument doesn't exist, create a new feito with this data.
     */
    create: XOR<feitoCreateInput, feitoUncheckedCreateInput>
    /**
     * In case the feito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<feitoUpdateInput, feitoUncheckedUpdateInput>
  }

  /**
   * feito delete
   */
  export type feitoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feito
     */
    select?: feitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feitoInclude<ExtArgs> | null
    /**
     * Filter which feito to delete.
     */
    where: feitoWhereUniqueInput
  }

  /**
   * feito deleteMany
   */
  export type feitoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feitos to delete
     */
    where?: feitoWhereInput
  }

  /**
   * feito without action
   */
  export type feitoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feito
     */
    select?: feitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feitoInclude<ExtArgs> | null
  }


  /**
   * Model grupo
   */

  export type AggregateGrupo = {
    _count: GrupoCountAggregateOutputType | null
    _avg: GrupoAvgAggregateOutputType | null
    _sum: GrupoSumAggregateOutputType | null
    _min: GrupoMinAggregateOutputType | null
    _max: GrupoMaxAggregateOutputType | null
  }

  export type GrupoAvgAggregateOutputType = {
    id: number | null
  }

  export type GrupoSumAggregateOutputType = {
    id: number | null
  }

  export type GrupoMinAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type GrupoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type GrupoCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type GrupoAvgAggregateInputType = {
    id?: true
  }

  export type GrupoSumAggregateInputType = {
    id?: true
  }

  export type GrupoMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type GrupoMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type GrupoCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type GrupoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grupo to aggregate.
     */
    where?: grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos to fetch.
     */
    orderBy?: grupoOrderByWithRelationInput | grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned grupos
    **/
    _count?: true | GrupoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GrupoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GrupoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GrupoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GrupoMaxAggregateInputType
  }

  export type GetGrupoAggregateType<T extends GrupoAggregateArgs> = {
        [P in keyof T & keyof AggregateGrupo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrupo[P]>
      : GetScalarType<T[P], AggregateGrupo[P]>
  }




  export type grupoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grupoWhereInput
    orderBy?: grupoOrderByWithAggregationInput | grupoOrderByWithAggregationInput[]
    by: GrupoScalarFieldEnum[] | GrupoScalarFieldEnum
    having?: grupoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GrupoCountAggregateInputType | true
    _avg?: GrupoAvgAggregateInputType
    _sum?: GrupoSumAggregateInputType
    _min?: GrupoMinAggregateInputType
    _max?: GrupoMaxAggregateInputType
  }

  export type GrupoGroupByOutputType = {
    id: number
    nome: string
    _count: GrupoCountAggregateOutputType | null
    _avg: GrupoAvgAggregateOutputType | null
    _sum: GrupoSumAggregateOutputType | null
    _min: GrupoMinAggregateOutputType | null
    _max: GrupoMaxAggregateOutputType | null
  }

  type GetGrupoGroupByPayload<T extends grupoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GrupoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GrupoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GrupoGroupByOutputType[P]>
            : GetScalarType<T[P], GrupoGroupByOutputType[P]>
        }
      >
    >


  export type grupoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    permissoes?: boolean | grupo$permissoesArgs<ExtArgs>
    usuario?: boolean | grupo$usuarioArgs<ExtArgs>
    _count?: boolean | GrupoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grupo"]>


  export type grupoSelectScalar = {
    id?: boolean
    nome?: boolean
  }

  export type grupoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissoes?: boolean | grupo$permissoesArgs<ExtArgs>
    usuario?: boolean | grupo$usuarioArgs<ExtArgs>
    _count?: boolean | GrupoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $grupoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "grupo"
    objects: {
      permissoes: Prisma.$permissoesPayload<ExtArgs>[]
      usuario: Prisma.$usuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
    }, ExtArgs["result"]["grupo"]>
    composites: {}
  }

  type grupoGetPayload<S extends boolean | null | undefined | grupoDefaultArgs> = $Result.GetResult<Prisma.$grupoPayload, S>

  type grupoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<grupoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GrupoCountAggregateInputType | true
    }

  export interface grupoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['grupo'], meta: { name: 'grupo' } }
    /**
     * Find zero or one Grupo that matches the filter.
     * @param {grupoFindUniqueArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends grupoFindUniqueArgs>(args: SelectSubset<T, grupoFindUniqueArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Grupo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {grupoFindUniqueOrThrowArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends grupoFindUniqueOrThrowArgs>(args: SelectSubset<T, grupoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Grupo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoFindFirstArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends grupoFindFirstArgs>(args?: SelectSubset<T, grupoFindFirstArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Grupo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoFindFirstOrThrowArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends grupoFindFirstOrThrowArgs>(args?: SelectSubset<T, grupoFindFirstOrThrowArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Grupos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grupos
     * const grupos = await prisma.grupo.findMany()
     * 
     * // Get first 10 Grupos
     * const grupos = await prisma.grupo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const grupoWithIdOnly = await prisma.grupo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends grupoFindManyArgs>(args?: SelectSubset<T, grupoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Grupo.
     * @param {grupoCreateArgs} args - Arguments to create a Grupo.
     * @example
     * // Create one Grupo
     * const Grupo = await prisma.grupo.create({
     *   data: {
     *     // ... data to create a Grupo
     *   }
     * })
     * 
     */
    create<T extends grupoCreateArgs>(args: SelectSubset<T, grupoCreateArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Grupos.
     * @param {grupoCreateManyArgs} args - Arguments to create many Grupos.
     * @example
     * // Create many Grupos
     * const grupo = await prisma.grupo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends grupoCreateManyArgs>(args?: SelectSubset<T, grupoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Grupo.
     * @param {grupoDeleteArgs} args - Arguments to delete one Grupo.
     * @example
     * // Delete one Grupo
     * const Grupo = await prisma.grupo.delete({
     *   where: {
     *     // ... filter to delete one Grupo
     *   }
     * })
     * 
     */
    delete<T extends grupoDeleteArgs>(args: SelectSubset<T, grupoDeleteArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Grupo.
     * @param {grupoUpdateArgs} args - Arguments to update one Grupo.
     * @example
     * // Update one Grupo
     * const grupo = await prisma.grupo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends grupoUpdateArgs>(args: SelectSubset<T, grupoUpdateArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Grupos.
     * @param {grupoDeleteManyArgs} args - Arguments to filter Grupos to delete.
     * @example
     * // Delete a few Grupos
     * const { count } = await prisma.grupo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends grupoDeleteManyArgs>(args?: SelectSubset<T, grupoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grupos
     * const grupo = await prisma.grupo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends grupoUpdateManyArgs>(args: SelectSubset<T, grupoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Grupo.
     * @param {grupoUpsertArgs} args - Arguments to update or create a Grupo.
     * @example
     * // Update or create a Grupo
     * const grupo = await prisma.grupo.upsert({
     *   create: {
     *     // ... data to create a Grupo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grupo we want to update
     *   }
     * })
     */
    upsert<T extends grupoUpsertArgs>(args: SelectSubset<T, grupoUpsertArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoCountArgs} args - Arguments to filter Grupos to count.
     * @example
     * // Count the number of Grupos
     * const count = await prisma.grupo.count({
     *   where: {
     *     // ... the filter for the Grupos we want to count
     *   }
     * })
    **/
    count<T extends grupoCountArgs>(
      args?: Subset<T, grupoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GrupoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GrupoAggregateArgs>(args: Subset<T, GrupoAggregateArgs>): Prisma.PrismaPromise<GetGrupoAggregateType<T>>

    /**
     * Group by Grupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends grupoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: grupoGroupByArgs['orderBy'] }
        : { orderBy?: grupoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, grupoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrupoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the grupo model
   */
  readonly fields: grupoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for grupo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__grupoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissoes<T extends grupo$permissoesArgs<ExtArgs> = {}>(args?: Subset<T, grupo$permissoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissoesPayload<ExtArgs>, T, "findMany"> | Null>
    usuario<T extends grupo$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, grupo$usuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the grupo model
   */ 
  interface grupoFieldRefs {
    readonly id: FieldRef<"grupo", 'Int'>
    readonly nome: FieldRef<"grupo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * grupo findUnique
   */
  export type grupoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * Filter, which grupo to fetch.
     */
    where: grupoWhereUniqueInput
  }

  /**
   * grupo findUniqueOrThrow
   */
  export type grupoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * Filter, which grupo to fetch.
     */
    where: grupoWhereUniqueInput
  }

  /**
   * grupo findFirst
   */
  export type grupoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * Filter, which grupo to fetch.
     */
    where?: grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos to fetch.
     */
    orderBy?: grupoOrderByWithRelationInput | grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grupos.
     */
    cursor?: grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grupos.
     */
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[]
  }

  /**
   * grupo findFirstOrThrow
   */
  export type grupoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * Filter, which grupo to fetch.
     */
    where?: grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos to fetch.
     */
    orderBy?: grupoOrderByWithRelationInput | grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grupos.
     */
    cursor?: grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grupos.
     */
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[]
  }

  /**
   * grupo findMany
   */
  export type grupoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * Filter, which grupos to fetch.
     */
    where?: grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos to fetch.
     */
    orderBy?: grupoOrderByWithRelationInput | grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing grupos.
     */
    cursor?: grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos.
     */
    skip?: number
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[]
  }

  /**
   * grupo create
   */
  export type grupoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * The data needed to create a grupo.
     */
    data: XOR<grupoCreateInput, grupoUncheckedCreateInput>
  }

  /**
   * grupo createMany
   */
  export type grupoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many grupos.
     */
    data: grupoCreateManyInput | grupoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * grupo update
   */
  export type grupoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * The data needed to update a grupo.
     */
    data: XOR<grupoUpdateInput, grupoUncheckedUpdateInput>
    /**
     * Choose, which grupo to update.
     */
    where: grupoWhereUniqueInput
  }

  /**
   * grupo updateMany
   */
  export type grupoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update grupos.
     */
    data: XOR<grupoUpdateManyMutationInput, grupoUncheckedUpdateManyInput>
    /**
     * Filter which grupos to update
     */
    where?: grupoWhereInput
  }

  /**
   * grupo upsert
   */
  export type grupoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * The filter to search for the grupo to update in case it exists.
     */
    where: grupoWhereUniqueInput
    /**
     * In case the grupo found by the `where` argument doesn't exist, create a new grupo with this data.
     */
    create: XOR<grupoCreateInput, grupoUncheckedCreateInput>
    /**
     * In case the grupo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<grupoUpdateInput, grupoUncheckedUpdateInput>
  }

  /**
   * grupo delete
   */
  export type grupoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * Filter which grupo to delete.
     */
    where: grupoWhereUniqueInput
  }

  /**
   * grupo deleteMany
   */
  export type grupoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grupos to delete
     */
    where?: grupoWhereInput
  }

  /**
   * grupo.permissoes
   */
  export type grupo$permissoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissoes
     */
    select?: permissoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissoesInclude<ExtArgs> | null
    where?: permissoesWhereInput
    orderBy?: permissoesOrderByWithRelationInput | permissoesOrderByWithRelationInput[]
    cursor?: permissoesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissoesScalarFieldEnum | PermissoesScalarFieldEnum[]
  }

  /**
   * grupo.usuario
   */
  export type grupo$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    cursor?: usuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * grupo without action
   */
  export type grupoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
  }


  /**
   * Model modulo
   */

  export type AggregateModulo = {
    _count: ModuloCountAggregateOutputType | null
    _avg: ModuloAvgAggregateOutputType | null
    _sum: ModuloSumAggregateOutputType | null
    _min: ModuloMinAggregateOutputType | null
    _max: ModuloMaxAggregateOutputType | null
  }

  export type ModuloAvgAggregateOutputType = {
    id: number | null
    turma_id: number | null
  }

  export type ModuloSumAggregateOutputType = {
    id: number | null
    turma_id: number | null
  }

  export type ModuloMinAggregateOutputType = {
    id: number | null
    turma_id: number | null
    titulo: string | null
    image: string | null
    descricao: string | null
  }

  export type ModuloMaxAggregateOutputType = {
    id: number | null
    turma_id: number | null
    titulo: string | null
    image: string | null
    descricao: string | null
  }

  export type ModuloCountAggregateOutputType = {
    id: number
    turma_id: number
    titulo: number
    image: number
    descricao: number
    _all: number
  }


  export type ModuloAvgAggregateInputType = {
    id?: true
    turma_id?: true
  }

  export type ModuloSumAggregateInputType = {
    id?: true
    turma_id?: true
  }

  export type ModuloMinAggregateInputType = {
    id?: true
    turma_id?: true
    titulo?: true
    image?: true
    descricao?: true
  }

  export type ModuloMaxAggregateInputType = {
    id?: true
    turma_id?: true
    titulo?: true
    image?: true
    descricao?: true
  }

  export type ModuloCountAggregateInputType = {
    id?: true
    turma_id?: true
    titulo?: true
    image?: true
    descricao?: true
    _all?: true
  }

  export type ModuloAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which modulo to aggregate.
     */
    where?: moduloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modulos to fetch.
     */
    orderBy?: moduloOrderByWithRelationInput | moduloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: moduloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned modulos
    **/
    _count?: true | ModuloCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuloAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuloSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuloMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuloMaxAggregateInputType
  }

  export type GetModuloAggregateType<T extends ModuloAggregateArgs> = {
        [P in keyof T & keyof AggregateModulo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModulo[P]>
      : GetScalarType<T[P], AggregateModulo[P]>
  }




  export type moduloGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: moduloWhereInput
    orderBy?: moduloOrderByWithAggregationInput | moduloOrderByWithAggregationInput[]
    by: ModuloScalarFieldEnum[] | ModuloScalarFieldEnum
    having?: moduloScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuloCountAggregateInputType | true
    _avg?: ModuloAvgAggregateInputType
    _sum?: ModuloSumAggregateInputType
    _min?: ModuloMinAggregateInputType
    _max?: ModuloMaxAggregateInputType
  }

  export type ModuloGroupByOutputType = {
    id: number
    turma_id: number
    titulo: string
    image: string | null
    descricao: string | null
    _count: ModuloCountAggregateOutputType | null
    _avg: ModuloAvgAggregateOutputType | null
    _sum: ModuloSumAggregateOutputType | null
    _min: ModuloMinAggregateOutputType | null
    _max: ModuloMaxAggregateOutputType | null
  }

  type GetModuloGroupByPayload<T extends moduloGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuloGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuloGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuloGroupByOutputType[P]>
            : GetScalarType<T[P], ModuloGroupByOutputType[P]>
        }
      >
    >


  export type moduloSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    turma_id?: boolean
    titulo?: boolean
    image?: boolean
    descricao?: boolean
    aula?: boolean | modulo$aulaArgs<ExtArgs>
    turma?: boolean | turmaDefaultArgs<ExtArgs>
    _count?: boolean | ModuloCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modulo"]>


  export type moduloSelectScalar = {
    id?: boolean
    turma_id?: boolean
    titulo?: boolean
    image?: boolean
    descricao?: boolean
  }

  export type moduloInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aula?: boolean | modulo$aulaArgs<ExtArgs>
    turma?: boolean | turmaDefaultArgs<ExtArgs>
    _count?: boolean | ModuloCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $moduloPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "modulo"
    objects: {
      aula: Prisma.$aulaPayload<ExtArgs>[]
      turma: Prisma.$turmaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      turma_id: number
      titulo: string
      image: string | null
      descricao: string | null
    }, ExtArgs["result"]["modulo"]>
    composites: {}
  }

  type moduloGetPayload<S extends boolean | null | undefined | moduloDefaultArgs> = $Result.GetResult<Prisma.$moduloPayload, S>

  type moduloCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<moduloFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuloCountAggregateInputType | true
    }

  export interface moduloDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['modulo'], meta: { name: 'modulo' } }
    /**
     * Find zero or one Modulo that matches the filter.
     * @param {moduloFindUniqueArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends moduloFindUniqueArgs>(args: SelectSubset<T, moduloFindUniqueArgs<ExtArgs>>): Prisma__moduloClient<$Result.GetResult<Prisma.$moduloPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Modulo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {moduloFindUniqueOrThrowArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends moduloFindUniqueOrThrowArgs>(args: SelectSubset<T, moduloFindUniqueOrThrowArgs<ExtArgs>>): Prisma__moduloClient<$Result.GetResult<Prisma.$moduloPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Modulo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moduloFindFirstArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends moduloFindFirstArgs>(args?: SelectSubset<T, moduloFindFirstArgs<ExtArgs>>): Prisma__moduloClient<$Result.GetResult<Prisma.$moduloPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Modulo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moduloFindFirstOrThrowArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends moduloFindFirstOrThrowArgs>(args?: SelectSubset<T, moduloFindFirstOrThrowArgs<ExtArgs>>): Prisma__moduloClient<$Result.GetResult<Prisma.$moduloPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Modulos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moduloFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modulos
     * const modulos = await prisma.modulo.findMany()
     * 
     * // Get first 10 Modulos
     * const modulos = await prisma.modulo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduloWithIdOnly = await prisma.modulo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends moduloFindManyArgs>(args?: SelectSubset<T, moduloFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$moduloPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Modulo.
     * @param {moduloCreateArgs} args - Arguments to create a Modulo.
     * @example
     * // Create one Modulo
     * const Modulo = await prisma.modulo.create({
     *   data: {
     *     // ... data to create a Modulo
     *   }
     * })
     * 
     */
    create<T extends moduloCreateArgs>(args: SelectSubset<T, moduloCreateArgs<ExtArgs>>): Prisma__moduloClient<$Result.GetResult<Prisma.$moduloPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Modulos.
     * @param {moduloCreateManyArgs} args - Arguments to create many Modulos.
     * @example
     * // Create many Modulos
     * const modulo = await prisma.modulo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends moduloCreateManyArgs>(args?: SelectSubset<T, moduloCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Modulo.
     * @param {moduloDeleteArgs} args - Arguments to delete one Modulo.
     * @example
     * // Delete one Modulo
     * const Modulo = await prisma.modulo.delete({
     *   where: {
     *     // ... filter to delete one Modulo
     *   }
     * })
     * 
     */
    delete<T extends moduloDeleteArgs>(args: SelectSubset<T, moduloDeleteArgs<ExtArgs>>): Prisma__moduloClient<$Result.GetResult<Prisma.$moduloPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Modulo.
     * @param {moduloUpdateArgs} args - Arguments to update one Modulo.
     * @example
     * // Update one Modulo
     * const modulo = await prisma.modulo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends moduloUpdateArgs>(args: SelectSubset<T, moduloUpdateArgs<ExtArgs>>): Prisma__moduloClient<$Result.GetResult<Prisma.$moduloPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Modulos.
     * @param {moduloDeleteManyArgs} args - Arguments to filter Modulos to delete.
     * @example
     * // Delete a few Modulos
     * const { count } = await prisma.modulo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends moduloDeleteManyArgs>(args?: SelectSubset<T, moduloDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moduloUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modulos
     * const modulo = await prisma.modulo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends moduloUpdateManyArgs>(args: SelectSubset<T, moduloUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Modulo.
     * @param {moduloUpsertArgs} args - Arguments to update or create a Modulo.
     * @example
     * // Update or create a Modulo
     * const modulo = await prisma.modulo.upsert({
     *   create: {
     *     // ... data to create a Modulo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Modulo we want to update
     *   }
     * })
     */
    upsert<T extends moduloUpsertArgs>(args: SelectSubset<T, moduloUpsertArgs<ExtArgs>>): Prisma__moduloClient<$Result.GetResult<Prisma.$moduloPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moduloCountArgs} args - Arguments to filter Modulos to count.
     * @example
     * // Count the number of Modulos
     * const count = await prisma.modulo.count({
     *   where: {
     *     // ... the filter for the Modulos we want to count
     *   }
     * })
    **/
    count<T extends moduloCountArgs>(
      args?: Subset<T, moduloCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuloCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Modulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuloAggregateArgs>(args: Subset<T, ModuloAggregateArgs>): Prisma.PrismaPromise<GetModuloAggregateType<T>>

    /**
     * Group by Modulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moduloGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends moduloGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: moduloGroupByArgs['orderBy'] }
        : { orderBy?: moduloGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, moduloGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuloGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the modulo model
   */
  readonly fields: moduloFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for modulo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__moduloClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aula<T extends modulo$aulaArgs<ExtArgs> = {}>(args?: Subset<T, modulo$aulaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aulaPayload<ExtArgs>, T, "findMany"> | Null>
    turma<T extends turmaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, turmaDefaultArgs<ExtArgs>>): Prisma__turmaClient<$Result.GetResult<Prisma.$turmaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the modulo model
   */ 
  interface moduloFieldRefs {
    readonly id: FieldRef<"modulo", 'Int'>
    readonly turma_id: FieldRef<"modulo", 'Int'>
    readonly titulo: FieldRef<"modulo", 'String'>
    readonly image: FieldRef<"modulo", 'String'>
    readonly descricao: FieldRef<"modulo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * modulo findUnique
   */
  export type moduloFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulo
     */
    select?: moduloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: moduloInclude<ExtArgs> | null
    /**
     * Filter, which modulo to fetch.
     */
    where: moduloWhereUniqueInput
  }

  /**
   * modulo findUniqueOrThrow
   */
  export type moduloFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulo
     */
    select?: moduloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: moduloInclude<ExtArgs> | null
    /**
     * Filter, which modulo to fetch.
     */
    where: moduloWhereUniqueInput
  }

  /**
   * modulo findFirst
   */
  export type moduloFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulo
     */
    select?: moduloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: moduloInclude<ExtArgs> | null
    /**
     * Filter, which modulo to fetch.
     */
    where?: moduloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modulos to fetch.
     */
    orderBy?: moduloOrderByWithRelationInput | moduloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for modulos.
     */
    cursor?: moduloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of modulos.
     */
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }

  /**
   * modulo findFirstOrThrow
   */
  export type moduloFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulo
     */
    select?: moduloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: moduloInclude<ExtArgs> | null
    /**
     * Filter, which modulo to fetch.
     */
    where?: moduloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modulos to fetch.
     */
    orderBy?: moduloOrderByWithRelationInput | moduloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for modulos.
     */
    cursor?: moduloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of modulos.
     */
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }

  /**
   * modulo findMany
   */
  export type moduloFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulo
     */
    select?: moduloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: moduloInclude<ExtArgs> | null
    /**
     * Filter, which modulos to fetch.
     */
    where?: moduloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modulos to fetch.
     */
    orderBy?: moduloOrderByWithRelationInput | moduloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing modulos.
     */
    cursor?: moduloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modulos.
     */
    skip?: number
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }

  /**
   * modulo create
   */
  export type moduloCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulo
     */
    select?: moduloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: moduloInclude<ExtArgs> | null
    /**
     * The data needed to create a modulo.
     */
    data: XOR<moduloCreateInput, moduloUncheckedCreateInput>
  }

  /**
   * modulo createMany
   */
  export type moduloCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many modulos.
     */
    data: moduloCreateManyInput | moduloCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * modulo update
   */
  export type moduloUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulo
     */
    select?: moduloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: moduloInclude<ExtArgs> | null
    /**
     * The data needed to update a modulo.
     */
    data: XOR<moduloUpdateInput, moduloUncheckedUpdateInput>
    /**
     * Choose, which modulo to update.
     */
    where: moduloWhereUniqueInput
  }

  /**
   * modulo updateMany
   */
  export type moduloUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update modulos.
     */
    data: XOR<moduloUpdateManyMutationInput, moduloUncheckedUpdateManyInput>
    /**
     * Filter which modulos to update
     */
    where?: moduloWhereInput
  }

  /**
   * modulo upsert
   */
  export type moduloUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulo
     */
    select?: moduloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: moduloInclude<ExtArgs> | null
    /**
     * The filter to search for the modulo to update in case it exists.
     */
    where: moduloWhereUniqueInput
    /**
     * In case the modulo found by the `where` argument doesn't exist, create a new modulo with this data.
     */
    create: XOR<moduloCreateInput, moduloUncheckedCreateInput>
    /**
     * In case the modulo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<moduloUpdateInput, moduloUncheckedUpdateInput>
  }

  /**
   * modulo delete
   */
  export type moduloDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulo
     */
    select?: moduloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: moduloInclude<ExtArgs> | null
    /**
     * Filter which modulo to delete.
     */
    where: moduloWhereUniqueInput
  }

  /**
   * modulo deleteMany
   */
  export type moduloDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which modulos to delete
     */
    where?: moduloWhereInput
  }

  /**
   * modulo.aula
   */
  export type modulo$aulaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aula
     */
    select?: aulaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aulaInclude<ExtArgs> | null
    where?: aulaWhereInput
    orderBy?: aulaOrderByWithRelationInput | aulaOrderByWithRelationInput[]
    cursor?: aulaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AulaScalarFieldEnum | AulaScalarFieldEnum[]
  }

  /**
   * modulo without action
   */
  export type moduloDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulo
     */
    select?: moduloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: moduloInclude<ExtArgs> | null
  }


  /**
   * Model permissoes
   */

  export type AggregatePermissoes = {
    _count: PermissoesCountAggregateOutputType | null
    _avg: PermissoesAvgAggregateOutputType | null
    _sum: PermissoesSumAggregateOutputType | null
    _min: PermissoesMinAggregateOutputType | null
    _max: PermissoesMaxAggregateOutputType | null
  }

  export type PermissoesAvgAggregateOutputType = {
    rota_id: number | null
    grupo_id: number | null
  }

  export type PermissoesSumAggregateOutputType = {
    rota_id: number | null
    grupo_id: number | null
  }

  export type PermissoesMinAggregateOutputType = {
    rota_id: number | null
    grupo_id: number | null
  }

  export type PermissoesMaxAggregateOutputType = {
    rota_id: number | null
    grupo_id: number | null
  }

  export type PermissoesCountAggregateOutputType = {
    rota_id: number
    grupo_id: number
    _all: number
  }


  export type PermissoesAvgAggregateInputType = {
    rota_id?: true
    grupo_id?: true
  }

  export type PermissoesSumAggregateInputType = {
    rota_id?: true
    grupo_id?: true
  }

  export type PermissoesMinAggregateInputType = {
    rota_id?: true
    grupo_id?: true
  }

  export type PermissoesMaxAggregateInputType = {
    rota_id?: true
    grupo_id?: true
  }

  export type PermissoesCountAggregateInputType = {
    rota_id?: true
    grupo_id?: true
    _all?: true
  }

  export type PermissoesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissoes to aggregate.
     */
    where?: permissoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissoes to fetch.
     */
    orderBy?: permissoesOrderByWithRelationInput | permissoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissoes
    **/
    _count?: true | PermissoesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissoesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissoesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissoesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissoesMaxAggregateInputType
  }

  export type GetPermissoesAggregateType<T extends PermissoesAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissoes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissoes[P]>
      : GetScalarType<T[P], AggregatePermissoes[P]>
  }




  export type permissoesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissoesWhereInput
    orderBy?: permissoesOrderByWithAggregationInput | permissoesOrderByWithAggregationInput[]
    by: PermissoesScalarFieldEnum[] | PermissoesScalarFieldEnum
    having?: permissoesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissoesCountAggregateInputType | true
    _avg?: PermissoesAvgAggregateInputType
    _sum?: PermissoesSumAggregateInputType
    _min?: PermissoesMinAggregateInputType
    _max?: PermissoesMaxAggregateInputType
  }

  export type PermissoesGroupByOutputType = {
    rota_id: number
    grupo_id: number
    _count: PermissoesCountAggregateOutputType | null
    _avg: PermissoesAvgAggregateOutputType | null
    _sum: PermissoesSumAggregateOutputType | null
    _min: PermissoesMinAggregateOutputType | null
    _max: PermissoesMaxAggregateOutputType | null
  }

  type GetPermissoesGroupByPayload<T extends permissoesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissoesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissoesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissoesGroupByOutputType[P]>
            : GetScalarType<T[P], PermissoesGroupByOutputType[P]>
        }
      >
    >


  export type permissoesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rota_id?: boolean
    grupo_id?: boolean
    grupo?: boolean | grupoDefaultArgs<ExtArgs>
    rota?: boolean | rotaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissoes"]>


  export type permissoesSelectScalar = {
    rota_id?: boolean
    grupo_id?: boolean
  }

  export type permissoesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grupo?: boolean | grupoDefaultArgs<ExtArgs>
    rota?: boolean | rotaDefaultArgs<ExtArgs>
  }

  export type $permissoesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permissoes"
    objects: {
      grupo: Prisma.$grupoPayload<ExtArgs>
      rota: Prisma.$rotaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      rota_id: number
      grupo_id: number
    }, ExtArgs["result"]["permissoes"]>
    composites: {}
  }

  type permissoesGetPayload<S extends boolean | null | undefined | permissoesDefaultArgs> = $Result.GetResult<Prisma.$permissoesPayload, S>

  type permissoesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<permissoesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissoesCountAggregateInputType | true
    }

  export interface permissoesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permissoes'], meta: { name: 'permissoes' } }
    /**
     * Find zero or one Permissoes that matches the filter.
     * @param {permissoesFindUniqueArgs} args - Arguments to find a Permissoes
     * @example
     * // Get one Permissoes
     * const permissoes = await prisma.permissoes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permissoesFindUniqueArgs>(args: SelectSubset<T, permissoesFindUniqueArgs<ExtArgs>>): Prisma__permissoesClient<$Result.GetResult<Prisma.$permissoesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permissoes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {permissoesFindUniqueOrThrowArgs} args - Arguments to find a Permissoes
     * @example
     * // Get one Permissoes
     * const permissoes = await prisma.permissoes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permissoesFindUniqueOrThrowArgs>(args: SelectSubset<T, permissoesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permissoesClient<$Result.GetResult<Prisma.$permissoesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permissoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissoesFindFirstArgs} args - Arguments to find a Permissoes
     * @example
     * // Get one Permissoes
     * const permissoes = await prisma.permissoes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permissoesFindFirstArgs>(args?: SelectSubset<T, permissoesFindFirstArgs<ExtArgs>>): Prisma__permissoesClient<$Result.GetResult<Prisma.$permissoesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permissoes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissoesFindFirstOrThrowArgs} args - Arguments to find a Permissoes
     * @example
     * // Get one Permissoes
     * const permissoes = await prisma.permissoes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permissoesFindFirstOrThrowArgs>(args?: SelectSubset<T, permissoesFindFirstOrThrowArgs<ExtArgs>>): Prisma__permissoesClient<$Result.GetResult<Prisma.$permissoesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissoesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissoes
     * const permissoes = await prisma.permissoes.findMany()
     * 
     * // Get first 10 Permissoes
     * const permissoes = await prisma.permissoes.findMany({ take: 10 })
     * 
     * // Only select the `rota_id`
     * const permissoesWithRota_idOnly = await prisma.permissoes.findMany({ select: { rota_id: true } })
     * 
     */
    findMany<T extends permissoesFindManyArgs>(args?: SelectSubset<T, permissoesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissoesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permissoes.
     * @param {permissoesCreateArgs} args - Arguments to create a Permissoes.
     * @example
     * // Create one Permissoes
     * const Permissoes = await prisma.permissoes.create({
     *   data: {
     *     // ... data to create a Permissoes
     *   }
     * })
     * 
     */
    create<T extends permissoesCreateArgs>(args: SelectSubset<T, permissoesCreateArgs<ExtArgs>>): Prisma__permissoesClient<$Result.GetResult<Prisma.$permissoesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissoes.
     * @param {permissoesCreateManyArgs} args - Arguments to create many Permissoes.
     * @example
     * // Create many Permissoes
     * const permissoes = await prisma.permissoes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permissoesCreateManyArgs>(args?: SelectSubset<T, permissoesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permissoes.
     * @param {permissoesDeleteArgs} args - Arguments to delete one Permissoes.
     * @example
     * // Delete one Permissoes
     * const Permissoes = await prisma.permissoes.delete({
     *   where: {
     *     // ... filter to delete one Permissoes
     *   }
     * })
     * 
     */
    delete<T extends permissoesDeleteArgs>(args: SelectSubset<T, permissoesDeleteArgs<ExtArgs>>): Prisma__permissoesClient<$Result.GetResult<Prisma.$permissoesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permissoes.
     * @param {permissoesUpdateArgs} args - Arguments to update one Permissoes.
     * @example
     * // Update one Permissoes
     * const permissoes = await prisma.permissoes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permissoesUpdateArgs>(args: SelectSubset<T, permissoesUpdateArgs<ExtArgs>>): Prisma__permissoesClient<$Result.GetResult<Prisma.$permissoesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissoes.
     * @param {permissoesDeleteManyArgs} args - Arguments to filter Permissoes to delete.
     * @example
     * // Delete a few Permissoes
     * const { count } = await prisma.permissoes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permissoesDeleteManyArgs>(args?: SelectSubset<T, permissoesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissoesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissoes
     * const permissoes = await prisma.permissoes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permissoesUpdateManyArgs>(args: SelectSubset<T, permissoesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permissoes.
     * @param {permissoesUpsertArgs} args - Arguments to update or create a Permissoes.
     * @example
     * // Update or create a Permissoes
     * const permissoes = await prisma.permissoes.upsert({
     *   create: {
     *     // ... data to create a Permissoes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissoes we want to update
     *   }
     * })
     */
    upsert<T extends permissoesUpsertArgs>(args: SelectSubset<T, permissoesUpsertArgs<ExtArgs>>): Prisma__permissoesClient<$Result.GetResult<Prisma.$permissoesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissoesCountArgs} args - Arguments to filter Permissoes to count.
     * @example
     * // Count the number of Permissoes
     * const count = await prisma.permissoes.count({
     *   where: {
     *     // ... the filter for the Permissoes we want to count
     *   }
     * })
    **/
    count<T extends permissoesCountArgs>(
      args?: Subset<T, permissoesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissoesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissoesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissoesAggregateArgs>(args: Subset<T, PermissoesAggregateArgs>): Prisma.PrismaPromise<GetPermissoesAggregateType<T>>

    /**
     * Group by Permissoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissoesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissoesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissoesGroupByArgs['orderBy'] }
        : { orderBy?: permissoesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissoesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissoesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permissoes model
   */
  readonly fields: permissoesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permissoes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permissoesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grupo<T extends grupoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, grupoDefaultArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rota<T extends rotaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rotaDefaultArgs<ExtArgs>>): Prisma__rotaClient<$Result.GetResult<Prisma.$rotaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permissoes model
   */ 
  interface permissoesFieldRefs {
    readonly rota_id: FieldRef<"permissoes", 'Int'>
    readonly grupo_id: FieldRef<"permissoes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * permissoes findUnique
   */
  export type permissoesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissoes
     */
    select?: permissoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissoesInclude<ExtArgs> | null
    /**
     * Filter, which permissoes to fetch.
     */
    where: permissoesWhereUniqueInput
  }

  /**
   * permissoes findUniqueOrThrow
   */
  export type permissoesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissoes
     */
    select?: permissoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissoesInclude<ExtArgs> | null
    /**
     * Filter, which permissoes to fetch.
     */
    where: permissoesWhereUniqueInput
  }

  /**
   * permissoes findFirst
   */
  export type permissoesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissoes
     */
    select?: permissoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissoesInclude<ExtArgs> | null
    /**
     * Filter, which permissoes to fetch.
     */
    where?: permissoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissoes to fetch.
     */
    orderBy?: permissoesOrderByWithRelationInput | permissoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissoes.
     */
    cursor?: permissoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissoes.
     */
    distinct?: PermissoesScalarFieldEnum | PermissoesScalarFieldEnum[]
  }

  /**
   * permissoes findFirstOrThrow
   */
  export type permissoesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissoes
     */
    select?: permissoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissoesInclude<ExtArgs> | null
    /**
     * Filter, which permissoes to fetch.
     */
    where?: permissoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissoes to fetch.
     */
    orderBy?: permissoesOrderByWithRelationInput | permissoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissoes.
     */
    cursor?: permissoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissoes.
     */
    distinct?: PermissoesScalarFieldEnum | PermissoesScalarFieldEnum[]
  }

  /**
   * permissoes findMany
   */
  export type permissoesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissoes
     */
    select?: permissoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissoesInclude<ExtArgs> | null
    /**
     * Filter, which permissoes to fetch.
     */
    where?: permissoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissoes to fetch.
     */
    orderBy?: permissoesOrderByWithRelationInput | permissoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissoes.
     */
    cursor?: permissoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissoes.
     */
    skip?: number
    distinct?: PermissoesScalarFieldEnum | PermissoesScalarFieldEnum[]
  }

  /**
   * permissoes create
   */
  export type permissoesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissoes
     */
    select?: permissoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissoesInclude<ExtArgs> | null
    /**
     * The data needed to create a permissoes.
     */
    data: XOR<permissoesCreateInput, permissoesUncheckedCreateInput>
  }

  /**
   * permissoes createMany
   */
  export type permissoesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissoes.
     */
    data: permissoesCreateManyInput | permissoesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permissoes update
   */
  export type permissoesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissoes
     */
    select?: permissoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissoesInclude<ExtArgs> | null
    /**
     * The data needed to update a permissoes.
     */
    data: XOR<permissoesUpdateInput, permissoesUncheckedUpdateInput>
    /**
     * Choose, which permissoes to update.
     */
    where: permissoesWhereUniqueInput
  }

  /**
   * permissoes updateMany
   */
  export type permissoesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissoes.
     */
    data: XOR<permissoesUpdateManyMutationInput, permissoesUncheckedUpdateManyInput>
    /**
     * Filter which permissoes to update
     */
    where?: permissoesWhereInput
  }

  /**
   * permissoes upsert
   */
  export type permissoesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissoes
     */
    select?: permissoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissoesInclude<ExtArgs> | null
    /**
     * The filter to search for the permissoes to update in case it exists.
     */
    where: permissoesWhereUniqueInput
    /**
     * In case the permissoes found by the `where` argument doesn't exist, create a new permissoes with this data.
     */
    create: XOR<permissoesCreateInput, permissoesUncheckedCreateInput>
    /**
     * In case the permissoes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissoesUpdateInput, permissoesUncheckedUpdateInput>
  }

  /**
   * permissoes delete
   */
  export type permissoesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissoes
     */
    select?: permissoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissoesInclude<ExtArgs> | null
    /**
     * Filter which permissoes to delete.
     */
    where: permissoesWhereUniqueInput
  }

  /**
   * permissoes deleteMany
   */
  export type permissoesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissoes to delete
     */
    where?: permissoesWhereInput
  }

  /**
   * permissoes without action
   */
  export type permissoesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissoes
     */
    select?: permissoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissoesInclude<ExtArgs> | null
  }


  /**
   * Model professor
   */

  export type AggregateProfessor = {
    _count: ProfessorCountAggregateOutputType | null
    _avg: ProfessorAvgAggregateOutputType | null
    _sum: ProfessorSumAggregateOutputType | null
    _min: ProfessorMinAggregateOutputType | null
    _max: ProfessorMaxAggregateOutputType | null
  }

  export type ProfessorAvgAggregateOutputType = {
    id: number | null
    turma_id: number | null
    usuario_id: number | null
  }

  export type ProfessorSumAggregateOutputType = {
    id: number | null
    turma_id: number | null
    usuario_id: number | null
  }

  export type ProfessorMinAggregateOutputType = {
    id: number | null
    turma_id: number | null
    usuario_id: number | null
  }

  export type ProfessorMaxAggregateOutputType = {
    id: number | null
    turma_id: number | null
    usuario_id: number | null
  }

  export type ProfessorCountAggregateOutputType = {
    id: number
    turma_id: number
    usuario_id: number
    _all: number
  }


  export type ProfessorAvgAggregateInputType = {
    id?: true
    turma_id?: true
    usuario_id?: true
  }

  export type ProfessorSumAggregateInputType = {
    id?: true
    turma_id?: true
    usuario_id?: true
  }

  export type ProfessorMinAggregateInputType = {
    id?: true
    turma_id?: true
    usuario_id?: true
  }

  export type ProfessorMaxAggregateInputType = {
    id?: true
    turma_id?: true
    usuario_id?: true
  }

  export type ProfessorCountAggregateInputType = {
    id?: true
    turma_id?: true
    usuario_id?: true
    _all?: true
  }

  export type ProfessorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which professor to aggregate.
     */
    where?: professorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of professors to fetch.
     */
    orderBy?: professorOrderByWithRelationInput | professorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: professorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` professors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` professors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned professors
    **/
    _count?: true | ProfessorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfessorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfessorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfessorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfessorMaxAggregateInputType
  }

  export type GetProfessorAggregateType<T extends ProfessorAggregateArgs> = {
        [P in keyof T & keyof AggregateProfessor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfessor[P]>
      : GetScalarType<T[P], AggregateProfessor[P]>
  }




  export type professorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: professorWhereInput
    orderBy?: professorOrderByWithAggregationInput | professorOrderByWithAggregationInput[]
    by: ProfessorScalarFieldEnum[] | ProfessorScalarFieldEnum
    having?: professorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfessorCountAggregateInputType | true
    _avg?: ProfessorAvgAggregateInputType
    _sum?: ProfessorSumAggregateInputType
    _min?: ProfessorMinAggregateInputType
    _max?: ProfessorMaxAggregateInputType
  }

  export type ProfessorGroupByOutputType = {
    id: number
    turma_id: number
    usuario_id: number
    _count: ProfessorCountAggregateOutputType | null
    _avg: ProfessorAvgAggregateOutputType | null
    _sum: ProfessorSumAggregateOutputType | null
    _min: ProfessorMinAggregateOutputType | null
    _max: ProfessorMaxAggregateOutputType | null
  }

  type GetProfessorGroupByPayload<T extends professorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfessorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfessorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfessorGroupByOutputType[P]>
            : GetScalarType<T[P], ProfessorGroupByOutputType[P]>
        }
      >
    >


  export type professorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    turma_id?: boolean
    usuario_id?: boolean
    turma?: boolean | turmaDefaultArgs<ExtArgs>
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["professor"]>


  export type professorSelectScalar = {
    id?: boolean
    turma_id?: boolean
    usuario_id?: boolean
  }

  export type professorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    turma?: boolean | turmaDefaultArgs<ExtArgs>
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }

  export type $professorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "professor"
    objects: {
      turma: Prisma.$turmaPayload<ExtArgs>
      usuario: Prisma.$usuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      turma_id: number
      usuario_id: number
    }, ExtArgs["result"]["professor"]>
    composites: {}
  }

  type professorGetPayload<S extends boolean | null | undefined | professorDefaultArgs> = $Result.GetResult<Prisma.$professorPayload, S>

  type professorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<professorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfessorCountAggregateInputType | true
    }

  export interface professorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['professor'], meta: { name: 'professor' } }
    /**
     * Find zero or one Professor that matches the filter.
     * @param {professorFindUniqueArgs} args - Arguments to find a Professor
     * @example
     * // Get one Professor
     * const professor = await prisma.professor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends professorFindUniqueArgs>(args: SelectSubset<T, professorFindUniqueArgs<ExtArgs>>): Prisma__professorClient<$Result.GetResult<Prisma.$professorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Professor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {professorFindUniqueOrThrowArgs} args - Arguments to find a Professor
     * @example
     * // Get one Professor
     * const professor = await prisma.professor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends professorFindUniqueOrThrowArgs>(args: SelectSubset<T, professorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__professorClient<$Result.GetResult<Prisma.$professorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Professor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professorFindFirstArgs} args - Arguments to find a Professor
     * @example
     * // Get one Professor
     * const professor = await prisma.professor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends professorFindFirstArgs>(args?: SelectSubset<T, professorFindFirstArgs<ExtArgs>>): Prisma__professorClient<$Result.GetResult<Prisma.$professorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Professor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professorFindFirstOrThrowArgs} args - Arguments to find a Professor
     * @example
     * // Get one Professor
     * const professor = await prisma.professor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends professorFindFirstOrThrowArgs>(args?: SelectSubset<T, professorFindFirstOrThrowArgs<ExtArgs>>): Prisma__professorClient<$Result.GetResult<Prisma.$professorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Professors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Professors
     * const professors = await prisma.professor.findMany()
     * 
     * // Get first 10 Professors
     * const professors = await prisma.professor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const professorWithIdOnly = await prisma.professor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends professorFindManyArgs>(args?: SelectSubset<T, professorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$professorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Professor.
     * @param {professorCreateArgs} args - Arguments to create a Professor.
     * @example
     * // Create one Professor
     * const Professor = await prisma.professor.create({
     *   data: {
     *     // ... data to create a Professor
     *   }
     * })
     * 
     */
    create<T extends professorCreateArgs>(args: SelectSubset<T, professorCreateArgs<ExtArgs>>): Prisma__professorClient<$Result.GetResult<Prisma.$professorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Professors.
     * @param {professorCreateManyArgs} args - Arguments to create many Professors.
     * @example
     * // Create many Professors
     * const professor = await prisma.professor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends professorCreateManyArgs>(args?: SelectSubset<T, professorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Professor.
     * @param {professorDeleteArgs} args - Arguments to delete one Professor.
     * @example
     * // Delete one Professor
     * const Professor = await prisma.professor.delete({
     *   where: {
     *     // ... filter to delete one Professor
     *   }
     * })
     * 
     */
    delete<T extends professorDeleteArgs>(args: SelectSubset<T, professorDeleteArgs<ExtArgs>>): Prisma__professorClient<$Result.GetResult<Prisma.$professorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Professor.
     * @param {professorUpdateArgs} args - Arguments to update one Professor.
     * @example
     * // Update one Professor
     * const professor = await prisma.professor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends professorUpdateArgs>(args: SelectSubset<T, professorUpdateArgs<ExtArgs>>): Prisma__professorClient<$Result.GetResult<Prisma.$professorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Professors.
     * @param {professorDeleteManyArgs} args - Arguments to filter Professors to delete.
     * @example
     * // Delete a few Professors
     * const { count } = await prisma.professor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends professorDeleteManyArgs>(args?: SelectSubset<T, professorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Professors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Professors
     * const professor = await prisma.professor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends professorUpdateManyArgs>(args: SelectSubset<T, professorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Professor.
     * @param {professorUpsertArgs} args - Arguments to update or create a Professor.
     * @example
     * // Update or create a Professor
     * const professor = await prisma.professor.upsert({
     *   create: {
     *     // ... data to create a Professor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Professor we want to update
     *   }
     * })
     */
    upsert<T extends professorUpsertArgs>(args: SelectSubset<T, professorUpsertArgs<ExtArgs>>): Prisma__professorClient<$Result.GetResult<Prisma.$professorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Professors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professorCountArgs} args - Arguments to filter Professors to count.
     * @example
     * // Count the number of Professors
     * const count = await prisma.professor.count({
     *   where: {
     *     // ... the filter for the Professors we want to count
     *   }
     * })
    **/
    count<T extends professorCountArgs>(
      args?: Subset<T, professorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfessorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Professor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfessorAggregateArgs>(args: Subset<T, ProfessorAggregateArgs>): Prisma.PrismaPromise<GetProfessorAggregateType<T>>

    /**
     * Group by Professor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends professorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: professorGroupByArgs['orderBy'] }
        : { orderBy?: professorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, professorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfessorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the professor model
   */
  readonly fields: professorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for professor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__professorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    turma<T extends turmaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, turmaDefaultArgs<ExtArgs>>): Prisma__turmaClient<$Result.GetResult<Prisma.$turmaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends usuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuarioDefaultArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the professor model
   */ 
  interface professorFieldRefs {
    readonly id: FieldRef<"professor", 'Int'>
    readonly turma_id: FieldRef<"professor", 'Int'>
    readonly usuario_id: FieldRef<"professor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * professor findUnique
   */
  export type professorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professor
     */
    select?: professorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professorInclude<ExtArgs> | null
    /**
     * Filter, which professor to fetch.
     */
    where: professorWhereUniqueInput
  }

  /**
   * professor findUniqueOrThrow
   */
  export type professorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professor
     */
    select?: professorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professorInclude<ExtArgs> | null
    /**
     * Filter, which professor to fetch.
     */
    where: professorWhereUniqueInput
  }

  /**
   * professor findFirst
   */
  export type professorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professor
     */
    select?: professorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professorInclude<ExtArgs> | null
    /**
     * Filter, which professor to fetch.
     */
    where?: professorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of professors to fetch.
     */
    orderBy?: professorOrderByWithRelationInput | professorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for professors.
     */
    cursor?: professorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` professors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` professors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of professors.
     */
    distinct?: ProfessorScalarFieldEnum | ProfessorScalarFieldEnum[]
  }

  /**
   * professor findFirstOrThrow
   */
  export type professorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professor
     */
    select?: professorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professorInclude<ExtArgs> | null
    /**
     * Filter, which professor to fetch.
     */
    where?: professorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of professors to fetch.
     */
    orderBy?: professorOrderByWithRelationInput | professorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for professors.
     */
    cursor?: professorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` professors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` professors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of professors.
     */
    distinct?: ProfessorScalarFieldEnum | ProfessorScalarFieldEnum[]
  }

  /**
   * professor findMany
   */
  export type professorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professor
     */
    select?: professorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professorInclude<ExtArgs> | null
    /**
     * Filter, which professors to fetch.
     */
    where?: professorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of professors to fetch.
     */
    orderBy?: professorOrderByWithRelationInput | professorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing professors.
     */
    cursor?: professorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` professors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` professors.
     */
    skip?: number
    distinct?: ProfessorScalarFieldEnum | ProfessorScalarFieldEnum[]
  }

  /**
   * professor create
   */
  export type professorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professor
     */
    select?: professorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professorInclude<ExtArgs> | null
    /**
     * The data needed to create a professor.
     */
    data: XOR<professorCreateInput, professorUncheckedCreateInput>
  }

  /**
   * professor createMany
   */
  export type professorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many professors.
     */
    data: professorCreateManyInput | professorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * professor update
   */
  export type professorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professor
     */
    select?: professorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professorInclude<ExtArgs> | null
    /**
     * The data needed to update a professor.
     */
    data: XOR<professorUpdateInput, professorUncheckedUpdateInput>
    /**
     * Choose, which professor to update.
     */
    where: professorWhereUniqueInput
  }

  /**
   * professor updateMany
   */
  export type professorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update professors.
     */
    data: XOR<professorUpdateManyMutationInput, professorUncheckedUpdateManyInput>
    /**
     * Filter which professors to update
     */
    where?: professorWhereInput
  }

  /**
   * professor upsert
   */
  export type professorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professor
     */
    select?: professorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professorInclude<ExtArgs> | null
    /**
     * The filter to search for the professor to update in case it exists.
     */
    where: professorWhereUniqueInput
    /**
     * In case the professor found by the `where` argument doesn't exist, create a new professor with this data.
     */
    create: XOR<professorCreateInput, professorUncheckedCreateInput>
    /**
     * In case the professor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<professorUpdateInput, professorUncheckedUpdateInput>
  }

  /**
   * professor delete
   */
  export type professorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professor
     */
    select?: professorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professorInclude<ExtArgs> | null
    /**
     * Filter which professor to delete.
     */
    where: professorWhereUniqueInput
  }

  /**
   * professor deleteMany
   */
  export type professorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which professors to delete
     */
    where?: professorWhereInput
  }

  /**
   * professor without action
   */
  export type professorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professor
     */
    select?: professorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professorInclude<ExtArgs> | null
  }


  /**
   * Model rota
   */

  export type AggregateRota = {
    _count: RotaCountAggregateOutputType | null
    _avg: RotaAvgAggregateOutputType | null
    _sum: RotaSumAggregateOutputType | null
    _min: RotaMinAggregateOutputType | null
    _max: RotaMaxAggregateOutputType | null
  }

  export type RotaAvgAggregateOutputType = {
    id: number | null
  }

  export type RotaSumAggregateOutputType = {
    id: number | null
  }

  export type RotaMinAggregateOutputType = {
    id: number | null
    rota: string | null
    get: boolean | null
    post: boolean | null
    patch: boolean | null
    put: boolean | null
    delete: boolean | null
  }

  export type RotaMaxAggregateOutputType = {
    id: number | null
    rota: string | null
    get: boolean | null
    post: boolean | null
    patch: boolean | null
    put: boolean | null
    delete: boolean | null
  }

  export type RotaCountAggregateOutputType = {
    id: number
    rota: number
    get: number
    post: number
    patch: number
    put: number
    delete: number
    _all: number
  }


  export type RotaAvgAggregateInputType = {
    id?: true
  }

  export type RotaSumAggregateInputType = {
    id?: true
  }

  export type RotaMinAggregateInputType = {
    id?: true
    rota?: true
    get?: true
    post?: true
    patch?: true
    put?: true
    delete?: true
  }

  export type RotaMaxAggregateInputType = {
    id?: true
    rota?: true
    get?: true
    post?: true
    patch?: true
    put?: true
    delete?: true
  }

  export type RotaCountAggregateInputType = {
    id?: true
    rota?: true
    get?: true
    post?: true
    patch?: true
    put?: true
    delete?: true
    _all?: true
  }

  export type RotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rota to aggregate.
     */
    where?: rotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rotas to fetch.
     */
    orderBy?: rotaOrderByWithRelationInput | rotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rotas
    **/
    _count?: true | RotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RotaMaxAggregateInputType
  }

  export type GetRotaAggregateType<T extends RotaAggregateArgs> = {
        [P in keyof T & keyof AggregateRota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRota[P]>
      : GetScalarType<T[P], AggregateRota[P]>
  }




  export type rotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rotaWhereInput
    orderBy?: rotaOrderByWithAggregationInput | rotaOrderByWithAggregationInput[]
    by: RotaScalarFieldEnum[] | RotaScalarFieldEnum
    having?: rotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RotaCountAggregateInputType | true
    _avg?: RotaAvgAggregateInputType
    _sum?: RotaSumAggregateInputType
    _min?: RotaMinAggregateInputType
    _max?: RotaMaxAggregateInputType
  }

  export type RotaGroupByOutputType = {
    id: number
    rota: string
    get: boolean
    post: boolean
    patch: boolean
    put: boolean
    delete: boolean
    _count: RotaCountAggregateOutputType | null
    _avg: RotaAvgAggregateOutputType | null
    _sum: RotaSumAggregateOutputType | null
    _min: RotaMinAggregateOutputType | null
    _max: RotaMaxAggregateOutputType | null
  }

  type GetRotaGroupByPayload<T extends rotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RotaGroupByOutputType[P]>
            : GetScalarType<T[P], RotaGroupByOutputType[P]>
        }
      >
    >


  export type rotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rota?: boolean
    get?: boolean
    post?: boolean
    patch?: boolean
    put?: boolean
    delete?: boolean
    permissoes?: boolean | rota$permissoesArgs<ExtArgs>
    _count?: boolean | RotaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rota"]>


  export type rotaSelectScalar = {
    id?: boolean
    rota?: boolean
    get?: boolean
    post?: boolean
    patch?: boolean
    put?: boolean
    delete?: boolean
  }

  export type rotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissoes?: boolean | rota$permissoesArgs<ExtArgs>
    _count?: boolean | RotaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rota"
    objects: {
      permissoes: Prisma.$permissoesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rota: string
      get: boolean
      post: boolean
      patch: boolean
      put: boolean
      delete: boolean
    }, ExtArgs["result"]["rota"]>
    composites: {}
  }

  type rotaGetPayload<S extends boolean | null | undefined | rotaDefaultArgs> = $Result.GetResult<Prisma.$rotaPayload, S>

  type rotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rotaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RotaCountAggregateInputType | true
    }

  export interface rotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rota'], meta: { name: 'rota' } }
    /**
     * Find zero or one Rota that matches the filter.
     * @param {rotaFindUniqueArgs} args - Arguments to find a Rota
     * @example
     * // Get one Rota
     * const rota = await prisma.rota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rotaFindUniqueArgs>(args: SelectSubset<T, rotaFindUniqueArgs<ExtArgs>>): Prisma__rotaClient<$Result.GetResult<Prisma.$rotaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rota that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rotaFindUniqueOrThrowArgs} args - Arguments to find a Rota
     * @example
     * // Get one Rota
     * const rota = await prisma.rota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rotaFindUniqueOrThrowArgs>(args: SelectSubset<T, rotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rotaClient<$Result.GetResult<Prisma.$rotaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rotaFindFirstArgs} args - Arguments to find a Rota
     * @example
     * // Get one Rota
     * const rota = await prisma.rota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rotaFindFirstArgs>(args?: SelectSubset<T, rotaFindFirstArgs<ExtArgs>>): Prisma__rotaClient<$Result.GetResult<Prisma.$rotaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rotaFindFirstOrThrowArgs} args - Arguments to find a Rota
     * @example
     * // Get one Rota
     * const rota = await prisma.rota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rotaFindFirstOrThrowArgs>(args?: SelectSubset<T, rotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__rotaClient<$Result.GetResult<Prisma.$rotaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rotas
     * const rotas = await prisma.rota.findMany()
     * 
     * // Get first 10 Rotas
     * const rotas = await prisma.rota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rotaWithIdOnly = await prisma.rota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rotaFindManyArgs>(args?: SelectSubset<T, rotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rotaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rota.
     * @param {rotaCreateArgs} args - Arguments to create a Rota.
     * @example
     * // Create one Rota
     * const Rota = await prisma.rota.create({
     *   data: {
     *     // ... data to create a Rota
     *   }
     * })
     * 
     */
    create<T extends rotaCreateArgs>(args: SelectSubset<T, rotaCreateArgs<ExtArgs>>): Prisma__rotaClient<$Result.GetResult<Prisma.$rotaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rotas.
     * @param {rotaCreateManyArgs} args - Arguments to create many Rotas.
     * @example
     * // Create many Rotas
     * const rota = await prisma.rota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rotaCreateManyArgs>(args?: SelectSubset<T, rotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rota.
     * @param {rotaDeleteArgs} args - Arguments to delete one Rota.
     * @example
     * // Delete one Rota
     * const Rota = await prisma.rota.delete({
     *   where: {
     *     // ... filter to delete one Rota
     *   }
     * })
     * 
     */
    delete<T extends rotaDeleteArgs>(args: SelectSubset<T, rotaDeleteArgs<ExtArgs>>): Prisma__rotaClient<$Result.GetResult<Prisma.$rotaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rota.
     * @param {rotaUpdateArgs} args - Arguments to update one Rota.
     * @example
     * // Update one Rota
     * const rota = await prisma.rota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rotaUpdateArgs>(args: SelectSubset<T, rotaUpdateArgs<ExtArgs>>): Prisma__rotaClient<$Result.GetResult<Prisma.$rotaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rotas.
     * @param {rotaDeleteManyArgs} args - Arguments to filter Rotas to delete.
     * @example
     * // Delete a few Rotas
     * const { count } = await prisma.rota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rotaDeleteManyArgs>(args?: SelectSubset<T, rotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rotas
     * const rota = await prisma.rota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rotaUpdateManyArgs>(args: SelectSubset<T, rotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rota.
     * @param {rotaUpsertArgs} args - Arguments to update or create a Rota.
     * @example
     * // Update or create a Rota
     * const rota = await prisma.rota.upsert({
     *   create: {
     *     // ... data to create a Rota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rota we want to update
     *   }
     * })
     */
    upsert<T extends rotaUpsertArgs>(args: SelectSubset<T, rotaUpsertArgs<ExtArgs>>): Prisma__rotaClient<$Result.GetResult<Prisma.$rotaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rotaCountArgs} args - Arguments to filter Rotas to count.
     * @example
     * // Count the number of Rotas
     * const count = await prisma.rota.count({
     *   where: {
     *     // ... the filter for the Rotas we want to count
     *   }
     * })
    **/
    count<T extends rotaCountArgs>(
      args?: Subset<T, rotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RotaAggregateArgs>(args: Subset<T, RotaAggregateArgs>): Prisma.PrismaPromise<GetRotaAggregateType<T>>

    /**
     * Group by Rota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rotaGroupByArgs['orderBy'] }
        : { orderBy?: rotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rota model
   */
  readonly fields: rotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissoes<T extends rota$permissoesArgs<ExtArgs> = {}>(args?: Subset<T, rota$permissoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissoesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rota model
   */ 
  interface rotaFieldRefs {
    readonly id: FieldRef<"rota", 'Int'>
    readonly rota: FieldRef<"rota", 'String'>
    readonly get: FieldRef<"rota", 'Boolean'>
    readonly post: FieldRef<"rota", 'Boolean'>
    readonly patch: FieldRef<"rota", 'Boolean'>
    readonly put: FieldRef<"rota", 'Boolean'>
    readonly delete: FieldRef<"rota", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * rota findUnique
   */
  export type rotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rota
     */
    select?: rotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rotaInclude<ExtArgs> | null
    /**
     * Filter, which rota to fetch.
     */
    where: rotaWhereUniqueInput
  }

  /**
   * rota findUniqueOrThrow
   */
  export type rotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rota
     */
    select?: rotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rotaInclude<ExtArgs> | null
    /**
     * Filter, which rota to fetch.
     */
    where: rotaWhereUniqueInput
  }

  /**
   * rota findFirst
   */
  export type rotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rota
     */
    select?: rotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rotaInclude<ExtArgs> | null
    /**
     * Filter, which rota to fetch.
     */
    where?: rotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rotas to fetch.
     */
    orderBy?: rotaOrderByWithRelationInput | rotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rotas.
     */
    cursor?: rotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rotas.
     */
    distinct?: RotaScalarFieldEnum | RotaScalarFieldEnum[]
  }

  /**
   * rota findFirstOrThrow
   */
  export type rotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rota
     */
    select?: rotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rotaInclude<ExtArgs> | null
    /**
     * Filter, which rota to fetch.
     */
    where?: rotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rotas to fetch.
     */
    orderBy?: rotaOrderByWithRelationInput | rotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rotas.
     */
    cursor?: rotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rotas.
     */
    distinct?: RotaScalarFieldEnum | RotaScalarFieldEnum[]
  }

  /**
   * rota findMany
   */
  export type rotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rota
     */
    select?: rotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rotaInclude<ExtArgs> | null
    /**
     * Filter, which rotas to fetch.
     */
    where?: rotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rotas to fetch.
     */
    orderBy?: rotaOrderByWithRelationInput | rotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rotas.
     */
    cursor?: rotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rotas.
     */
    skip?: number
    distinct?: RotaScalarFieldEnum | RotaScalarFieldEnum[]
  }

  /**
   * rota create
   */
  export type rotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rota
     */
    select?: rotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rotaInclude<ExtArgs> | null
    /**
     * The data needed to create a rota.
     */
    data: XOR<rotaCreateInput, rotaUncheckedCreateInput>
  }

  /**
   * rota createMany
   */
  export type rotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rotas.
     */
    data: rotaCreateManyInput | rotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rota update
   */
  export type rotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rota
     */
    select?: rotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rotaInclude<ExtArgs> | null
    /**
     * The data needed to update a rota.
     */
    data: XOR<rotaUpdateInput, rotaUncheckedUpdateInput>
    /**
     * Choose, which rota to update.
     */
    where: rotaWhereUniqueInput
  }

  /**
   * rota updateMany
   */
  export type rotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rotas.
     */
    data: XOR<rotaUpdateManyMutationInput, rotaUncheckedUpdateManyInput>
    /**
     * Filter which rotas to update
     */
    where?: rotaWhereInput
  }

  /**
   * rota upsert
   */
  export type rotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rota
     */
    select?: rotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rotaInclude<ExtArgs> | null
    /**
     * The filter to search for the rota to update in case it exists.
     */
    where: rotaWhereUniqueInput
    /**
     * In case the rota found by the `where` argument doesn't exist, create a new rota with this data.
     */
    create: XOR<rotaCreateInput, rotaUncheckedCreateInput>
    /**
     * In case the rota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rotaUpdateInput, rotaUncheckedUpdateInput>
  }

  /**
   * rota delete
   */
  export type rotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rota
     */
    select?: rotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rotaInclude<ExtArgs> | null
    /**
     * Filter which rota to delete.
     */
    where: rotaWhereUniqueInput
  }

  /**
   * rota deleteMany
   */
  export type rotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rotas to delete
     */
    where?: rotaWhereInput
  }

  /**
   * rota.permissoes
   */
  export type rota$permissoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissoes
     */
    select?: permissoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissoesInclude<ExtArgs> | null
    where?: permissoesWhereInput
    orderBy?: permissoesOrderByWithRelationInput | permissoesOrderByWithRelationInput[]
    cursor?: permissoesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissoesScalarFieldEnum | PermissoesScalarFieldEnum[]
  }

  /**
   * rota without action
   */
  export type rotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rota
     */
    select?: rotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rotaInclude<ExtArgs> | null
  }


  /**
   * Model turma
   */

  export type AggregateTurma = {
    _count: TurmaCountAggregateOutputType | null
    _avg: TurmaAvgAggregateOutputType | null
    _sum: TurmaSumAggregateOutputType | null
    _min: TurmaMinAggregateOutputType | null
    _max: TurmaMaxAggregateOutputType | null
  }

  export type TurmaAvgAggregateOutputType = {
    id: number | null
  }

  export type TurmaSumAggregateOutputType = {
    id: number | null
  }

  export type TurmaMinAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type TurmaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type TurmaCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type TurmaAvgAggregateInputType = {
    id?: true
  }

  export type TurmaSumAggregateInputType = {
    id?: true
  }

  export type TurmaMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type TurmaMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type TurmaCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type TurmaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which turma to aggregate.
     */
    where?: turmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of turmas to fetch.
     */
    orderBy?: turmaOrderByWithRelationInput | turmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: turmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` turmas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned turmas
    **/
    _count?: true | TurmaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TurmaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TurmaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TurmaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TurmaMaxAggregateInputType
  }

  export type GetTurmaAggregateType<T extends TurmaAggregateArgs> = {
        [P in keyof T & keyof AggregateTurma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTurma[P]>
      : GetScalarType<T[P], AggregateTurma[P]>
  }




  export type turmaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: turmaWhereInput
    orderBy?: turmaOrderByWithAggregationInput | turmaOrderByWithAggregationInput[]
    by: TurmaScalarFieldEnum[] | TurmaScalarFieldEnum
    having?: turmaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TurmaCountAggregateInputType | true
    _avg?: TurmaAvgAggregateInputType
    _sum?: TurmaSumAggregateInputType
    _min?: TurmaMinAggregateInputType
    _max?: TurmaMaxAggregateInputType
  }

  export type TurmaGroupByOutputType = {
    id: number
    nome: string
    _count: TurmaCountAggregateOutputType | null
    _avg: TurmaAvgAggregateOutputType | null
    _sum: TurmaSumAggregateOutputType | null
    _min: TurmaMinAggregateOutputType | null
    _max: TurmaMaxAggregateOutputType | null
  }

  type GetTurmaGroupByPayload<T extends turmaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TurmaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TurmaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TurmaGroupByOutputType[P]>
            : GetScalarType<T[P], TurmaGroupByOutputType[P]>
        }
      >
    >


  export type turmaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    aluno?: boolean | turma$alunoArgs<ExtArgs>
    modulo?: boolean | turma$moduloArgs<ExtArgs>
    professor?: boolean | turma$professorArgs<ExtArgs>
    _count?: boolean | TurmaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["turma"]>


  export type turmaSelectScalar = {
    id?: boolean
    nome?: boolean
  }

  export type turmaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aluno?: boolean | turma$alunoArgs<ExtArgs>
    modulo?: boolean | turma$moduloArgs<ExtArgs>
    professor?: boolean | turma$professorArgs<ExtArgs>
    _count?: boolean | TurmaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $turmaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "turma"
    objects: {
      aluno: Prisma.$alunoPayload<ExtArgs>[]
      modulo: Prisma.$moduloPayload<ExtArgs>[]
      professor: Prisma.$professorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
    }, ExtArgs["result"]["turma"]>
    composites: {}
  }

  type turmaGetPayload<S extends boolean | null | undefined | turmaDefaultArgs> = $Result.GetResult<Prisma.$turmaPayload, S>

  type turmaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<turmaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TurmaCountAggregateInputType | true
    }

  export interface turmaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['turma'], meta: { name: 'turma' } }
    /**
     * Find zero or one Turma that matches the filter.
     * @param {turmaFindUniqueArgs} args - Arguments to find a Turma
     * @example
     * // Get one Turma
     * const turma = await prisma.turma.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends turmaFindUniqueArgs>(args: SelectSubset<T, turmaFindUniqueArgs<ExtArgs>>): Prisma__turmaClient<$Result.GetResult<Prisma.$turmaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Turma that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {turmaFindUniqueOrThrowArgs} args - Arguments to find a Turma
     * @example
     * // Get one Turma
     * const turma = await prisma.turma.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends turmaFindUniqueOrThrowArgs>(args: SelectSubset<T, turmaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__turmaClient<$Result.GetResult<Prisma.$turmaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Turma that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turmaFindFirstArgs} args - Arguments to find a Turma
     * @example
     * // Get one Turma
     * const turma = await prisma.turma.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends turmaFindFirstArgs>(args?: SelectSubset<T, turmaFindFirstArgs<ExtArgs>>): Prisma__turmaClient<$Result.GetResult<Prisma.$turmaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Turma that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turmaFindFirstOrThrowArgs} args - Arguments to find a Turma
     * @example
     * // Get one Turma
     * const turma = await prisma.turma.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends turmaFindFirstOrThrowArgs>(args?: SelectSubset<T, turmaFindFirstOrThrowArgs<ExtArgs>>): Prisma__turmaClient<$Result.GetResult<Prisma.$turmaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Turmas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turmaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Turmas
     * const turmas = await prisma.turma.findMany()
     * 
     * // Get first 10 Turmas
     * const turmas = await prisma.turma.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const turmaWithIdOnly = await prisma.turma.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends turmaFindManyArgs>(args?: SelectSubset<T, turmaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$turmaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Turma.
     * @param {turmaCreateArgs} args - Arguments to create a Turma.
     * @example
     * // Create one Turma
     * const Turma = await prisma.turma.create({
     *   data: {
     *     // ... data to create a Turma
     *   }
     * })
     * 
     */
    create<T extends turmaCreateArgs>(args: SelectSubset<T, turmaCreateArgs<ExtArgs>>): Prisma__turmaClient<$Result.GetResult<Prisma.$turmaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Turmas.
     * @param {turmaCreateManyArgs} args - Arguments to create many Turmas.
     * @example
     * // Create many Turmas
     * const turma = await prisma.turma.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends turmaCreateManyArgs>(args?: SelectSubset<T, turmaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Turma.
     * @param {turmaDeleteArgs} args - Arguments to delete one Turma.
     * @example
     * // Delete one Turma
     * const Turma = await prisma.turma.delete({
     *   where: {
     *     // ... filter to delete one Turma
     *   }
     * })
     * 
     */
    delete<T extends turmaDeleteArgs>(args: SelectSubset<T, turmaDeleteArgs<ExtArgs>>): Prisma__turmaClient<$Result.GetResult<Prisma.$turmaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Turma.
     * @param {turmaUpdateArgs} args - Arguments to update one Turma.
     * @example
     * // Update one Turma
     * const turma = await prisma.turma.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends turmaUpdateArgs>(args: SelectSubset<T, turmaUpdateArgs<ExtArgs>>): Prisma__turmaClient<$Result.GetResult<Prisma.$turmaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Turmas.
     * @param {turmaDeleteManyArgs} args - Arguments to filter Turmas to delete.
     * @example
     * // Delete a few Turmas
     * const { count } = await prisma.turma.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends turmaDeleteManyArgs>(args?: SelectSubset<T, turmaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Turmas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turmaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Turmas
     * const turma = await prisma.turma.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends turmaUpdateManyArgs>(args: SelectSubset<T, turmaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Turma.
     * @param {turmaUpsertArgs} args - Arguments to update or create a Turma.
     * @example
     * // Update or create a Turma
     * const turma = await prisma.turma.upsert({
     *   create: {
     *     // ... data to create a Turma
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Turma we want to update
     *   }
     * })
     */
    upsert<T extends turmaUpsertArgs>(args: SelectSubset<T, turmaUpsertArgs<ExtArgs>>): Prisma__turmaClient<$Result.GetResult<Prisma.$turmaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Turmas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turmaCountArgs} args - Arguments to filter Turmas to count.
     * @example
     * // Count the number of Turmas
     * const count = await prisma.turma.count({
     *   where: {
     *     // ... the filter for the Turmas we want to count
     *   }
     * })
    **/
    count<T extends turmaCountArgs>(
      args?: Subset<T, turmaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TurmaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Turma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TurmaAggregateArgs>(args: Subset<T, TurmaAggregateArgs>): Prisma.PrismaPromise<GetTurmaAggregateType<T>>

    /**
     * Group by Turma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turmaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends turmaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: turmaGroupByArgs['orderBy'] }
        : { orderBy?: turmaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, turmaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTurmaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the turma model
   */
  readonly fields: turmaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for turma.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__turmaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aluno<T extends turma$alunoArgs<ExtArgs> = {}>(args?: Subset<T, turma$alunoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alunoPayload<ExtArgs>, T, "findMany"> | Null>
    modulo<T extends turma$moduloArgs<ExtArgs> = {}>(args?: Subset<T, turma$moduloArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$moduloPayload<ExtArgs>, T, "findMany"> | Null>
    professor<T extends turma$professorArgs<ExtArgs> = {}>(args?: Subset<T, turma$professorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$professorPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the turma model
   */ 
  interface turmaFieldRefs {
    readonly id: FieldRef<"turma", 'Int'>
    readonly nome: FieldRef<"turma", 'String'>
  }
    

  // Custom InputTypes
  /**
   * turma findUnique
   */
  export type turmaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turma
     */
    select?: turmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: turmaInclude<ExtArgs> | null
    /**
     * Filter, which turma to fetch.
     */
    where: turmaWhereUniqueInput
  }

  /**
   * turma findUniqueOrThrow
   */
  export type turmaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turma
     */
    select?: turmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: turmaInclude<ExtArgs> | null
    /**
     * Filter, which turma to fetch.
     */
    where: turmaWhereUniqueInput
  }

  /**
   * turma findFirst
   */
  export type turmaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turma
     */
    select?: turmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: turmaInclude<ExtArgs> | null
    /**
     * Filter, which turma to fetch.
     */
    where?: turmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of turmas to fetch.
     */
    orderBy?: turmaOrderByWithRelationInput | turmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for turmas.
     */
    cursor?: turmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` turmas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of turmas.
     */
    distinct?: TurmaScalarFieldEnum | TurmaScalarFieldEnum[]
  }

  /**
   * turma findFirstOrThrow
   */
  export type turmaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turma
     */
    select?: turmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: turmaInclude<ExtArgs> | null
    /**
     * Filter, which turma to fetch.
     */
    where?: turmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of turmas to fetch.
     */
    orderBy?: turmaOrderByWithRelationInput | turmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for turmas.
     */
    cursor?: turmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` turmas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of turmas.
     */
    distinct?: TurmaScalarFieldEnum | TurmaScalarFieldEnum[]
  }

  /**
   * turma findMany
   */
  export type turmaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turma
     */
    select?: turmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: turmaInclude<ExtArgs> | null
    /**
     * Filter, which turmas to fetch.
     */
    where?: turmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of turmas to fetch.
     */
    orderBy?: turmaOrderByWithRelationInput | turmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing turmas.
     */
    cursor?: turmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` turmas.
     */
    skip?: number
    distinct?: TurmaScalarFieldEnum | TurmaScalarFieldEnum[]
  }

  /**
   * turma create
   */
  export type turmaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turma
     */
    select?: turmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: turmaInclude<ExtArgs> | null
    /**
     * The data needed to create a turma.
     */
    data: XOR<turmaCreateInput, turmaUncheckedCreateInput>
  }

  /**
   * turma createMany
   */
  export type turmaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many turmas.
     */
    data: turmaCreateManyInput | turmaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * turma update
   */
  export type turmaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turma
     */
    select?: turmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: turmaInclude<ExtArgs> | null
    /**
     * The data needed to update a turma.
     */
    data: XOR<turmaUpdateInput, turmaUncheckedUpdateInput>
    /**
     * Choose, which turma to update.
     */
    where: turmaWhereUniqueInput
  }

  /**
   * turma updateMany
   */
  export type turmaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update turmas.
     */
    data: XOR<turmaUpdateManyMutationInput, turmaUncheckedUpdateManyInput>
    /**
     * Filter which turmas to update
     */
    where?: turmaWhereInput
  }

  /**
   * turma upsert
   */
  export type turmaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turma
     */
    select?: turmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: turmaInclude<ExtArgs> | null
    /**
     * The filter to search for the turma to update in case it exists.
     */
    where: turmaWhereUniqueInput
    /**
     * In case the turma found by the `where` argument doesn't exist, create a new turma with this data.
     */
    create: XOR<turmaCreateInput, turmaUncheckedCreateInput>
    /**
     * In case the turma was found with the provided `where` argument, update it with this data.
     */
    update: XOR<turmaUpdateInput, turmaUncheckedUpdateInput>
  }

  /**
   * turma delete
   */
  export type turmaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turma
     */
    select?: turmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: turmaInclude<ExtArgs> | null
    /**
     * Filter which turma to delete.
     */
    where: turmaWhereUniqueInput
  }

  /**
   * turma deleteMany
   */
  export type turmaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which turmas to delete
     */
    where?: turmaWhereInput
  }

  /**
   * turma.aluno
   */
  export type turma$alunoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aluno
     */
    select?: alunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alunoInclude<ExtArgs> | null
    where?: alunoWhereInput
    orderBy?: alunoOrderByWithRelationInput | alunoOrderByWithRelationInput[]
    cursor?: alunoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlunoScalarFieldEnum | AlunoScalarFieldEnum[]
  }

  /**
   * turma.modulo
   */
  export type turma$moduloArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulo
     */
    select?: moduloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: moduloInclude<ExtArgs> | null
    where?: moduloWhereInput
    orderBy?: moduloOrderByWithRelationInput | moduloOrderByWithRelationInput[]
    cursor?: moduloWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }

  /**
   * turma.professor
   */
  export type turma$professorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professor
     */
    select?: professorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professorInclude<ExtArgs> | null
    where?: professorWhereInput
    orderBy?: professorOrderByWithRelationInput | professorOrderByWithRelationInput[]
    cursor?: professorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfessorScalarFieldEnum | ProfessorScalarFieldEnum[]
  }

  /**
   * turma without action
   */
  export type turmaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turma
     */
    select?: turmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: turmaInclude<ExtArgs> | null
  }


  /**
   * Model usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
    grupo_id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
    grupo_id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nome: string | null
    grupo_id: number | null
    senha: string | null
    matricula: string | null
    active: boolean | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    grupo_id: number | null
    senha: string | null
    matricula: string | null
    active: boolean | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nome: number
    grupo_id: number
    senha: number
    matricula: number
    active: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
    grupo_id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
    grupo_id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nome?: true
    grupo_id?: true
    senha?: true
    matricula?: true
    active?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nome?: true
    grupo_id?: true
    senha?: true
    matricula?: true
    active?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nome?: true
    grupo_id?: true
    senha?: true
    matricula?: true
    active?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuario to aggregate.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type usuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuarioWhereInput
    orderBy?: usuarioOrderByWithAggregationInput | usuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    nome: string
    grupo_id: number
    senha: string
    matricula: string
    active: boolean
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends usuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type usuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    grupo_id?: boolean
    senha?: boolean
    matricula?: boolean
    active?: boolean
    aluno?: boolean | usuario$alunoArgs<ExtArgs>
    professor?: boolean | usuario$professorArgs<ExtArgs>
    grupo?: boolean | grupoDefaultArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>


  export type usuarioSelectScalar = {
    id?: boolean
    nome?: boolean
    grupo_id?: boolean
    senha?: boolean
    matricula?: boolean
    active?: boolean
  }

  export type usuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aluno?: boolean | usuario$alunoArgs<ExtArgs>
    professor?: boolean | usuario$professorArgs<ExtArgs>
    grupo?: boolean | grupoDefaultArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuario"
    objects: {
      aluno: Prisma.$alunoPayload<ExtArgs>[]
      professor: Prisma.$professorPayload<ExtArgs>[]
      grupo: Prisma.$grupoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      grupo_id: number
      senha: string
      matricula: string
      active: boolean
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type usuarioGetPayload<S extends boolean | null | undefined | usuarioDefaultArgs> = $Result.GetResult<Prisma.$usuarioPayload, S>

  type usuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface usuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuario'], meta: { name: 'usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {usuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuarioFindUniqueArgs>(args: SelectSubset<T, usuarioFindUniqueArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, usuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuarioFindFirstArgs>(args?: SelectSubset<T, usuarioFindFirstArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, usuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usuarioFindManyArgs>(args?: SelectSubset<T, usuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {usuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends usuarioCreateArgs>(args: SelectSubset<T, usuarioCreateArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {usuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuarioCreateManyArgs>(args?: SelectSubset<T, usuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {usuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends usuarioDeleteArgs>(args: SelectSubset<T, usuarioDeleteArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {usuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuarioUpdateArgs>(args: SelectSubset<T, usuarioUpdateArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {usuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuarioDeleteManyArgs>(args?: SelectSubset<T, usuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuarioUpdateManyArgs>(args: SelectSubset<T, usuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {usuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends usuarioUpsertArgs>(args: SelectSubset<T, usuarioUpsertArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuarioCountArgs>(
      args?: Subset<T, usuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuarioGroupByArgs['orderBy'] }
        : { orderBy?: usuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuario model
   */
  readonly fields: usuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aluno<T extends usuario$alunoArgs<ExtArgs> = {}>(args?: Subset<T, usuario$alunoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alunoPayload<ExtArgs>, T, "findMany"> | Null>
    professor<T extends usuario$professorArgs<ExtArgs> = {}>(args?: Subset<T, usuario$professorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$professorPayload<ExtArgs>, T, "findMany"> | Null>
    grupo<T extends grupoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, grupoDefaultArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuario model
   */ 
  interface usuarioFieldRefs {
    readonly id: FieldRef<"usuario", 'Int'>
    readonly nome: FieldRef<"usuario", 'String'>
    readonly grupo_id: FieldRef<"usuario", 'Int'>
    readonly senha: FieldRef<"usuario", 'String'>
    readonly matricula: FieldRef<"usuario", 'String'>
    readonly active: FieldRef<"usuario", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * usuario findUnique
   */
  export type usuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario findUniqueOrThrow
   */
  export type usuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario findFirst
   */
  export type usuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario findFirstOrThrow
   */
  export type usuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario findMany
   */
  export type usuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario create
   */
  export type usuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a usuario.
     */
    data: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
  }

  /**
   * usuario createMany
   */
  export type usuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuarios.
     */
    data: usuarioCreateManyInput | usuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuario update
   */
  export type usuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a usuario.
     */
    data: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
    /**
     * Choose, which usuario to update.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario updateMany
   */
  export type usuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuarioWhereInput
  }

  /**
   * usuario upsert
   */
  export type usuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the usuario to update in case it exists.
     */
    where: usuarioWhereUniqueInput
    /**
     * In case the usuario found by the `where` argument doesn't exist, create a new usuario with this data.
     */
    create: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
    /**
     * In case the usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
  }

  /**
   * usuario delete
   */
  export type usuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter which usuario to delete.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario deleteMany
   */
  export type usuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios to delete
     */
    where?: usuarioWhereInput
  }

  /**
   * usuario.aluno
   */
  export type usuario$alunoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aluno
     */
    select?: alunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alunoInclude<ExtArgs> | null
    where?: alunoWhereInput
    orderBy?: alunoOrderByWithRelationInput | alunoOrderByWithRelationInput[]
    cursor?: alunoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlunoScalarFieldEnum | AlunoScalarFieldEnum[]
  }

  /**
   * usuario.professor
   */
  export type usuario$professorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professor
     */
    select?: professorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professorInclude<ExtArgs> | null
    where?: professorWhereInput
    orderBy?: professorOrderByWithRelationInput | professorOrderByWithRelationInput[]
    cursor?: professorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfessorScalarFieldEnum | ProfessorScalarFieldEnum[]
  }

  /**
   * usuario without action
   */
  export type usuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AlunoScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    turma_id: 'turma_id'
  };

  export type AlunoScalarFieldEnum = (typeof AlunoScalarFieldEnum)[keyof typeof AlunoScalarFieldEnum]


  export const AulaScalarFieldEnum: {
    id: 'id',
    modulo_id: 'modulo_id',
    titulo: 'titulo',
    video: 'video',
    pdf_questoes: 'pdf_questoes',
    pdf_resolucao: 'pdf_resolucao',
    descricao: 'descricao'
  };

  export type AulaScalarFieldEnum = (typeof AulaScalarFieldEnum)[keyof typeof AulaScalarFieldEnum]


  export const FeitoScalarFieldEnum: {
    id: 'id',
    feito: 'feito',
    revisar: 'revisar',
    aula_id: 'aula_id',
    aluno_id: 'aluno_id'
  };

  export type FeitoScalarFieldEnum = (typeof FeitoScalarFieldEnum)[keyof typeof FeitoScalarFieldEnum]


  export const GrupoScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type GrupoScalarFieldEnum = (typeof GrupoScalarFieldEnum)[keyof typeof GrupoScalarFieldEnum]


  export const ModuloScalarFieldEnum: {
    id: 'id',
    turma_id: 'turma_id',
    titulo: 'titulo',
    image: 'image',
    descricao: 'descricao'
  };

  export type ModuloScalarFieldEnum = (typeof ModuloScalarFieldEnum)[keyof typeof ModuloScalarFieldEnum]


  export const PermissoesScalarFieldEnum: {
    rota_id: 'rota_id',
    grupo_id: 'grupo_id'
  };

  export type PermissoesScalarFieldEnum = (typeof PermissoesScalarFieldEnum)[keyof typeof PermissoesScalarFieldEnum]


  export const ProfessorScalarFieldEnum: {
    id: 'id',
    turma_id: 'turma_id',
    usuario_id: 'usuario_id'
  };

  export type ProfessorScalarFieldEnum = (typeof ProfessorScalarFieldEnum)[keyof typeof ProfessorScalarFieldEnum]


  export const RotaScalarFieldEnum: {
    id: 'id',
    rota: 'rota',
    get: 'get',
    post: 'post',
    patch: 'patch',
    put: 'put',
    delete: 'delete'
  };

  export type RotaScalarFieldEnum = (typeof RotaScalarFieldEnum)[keyof typeof RotaScalarFieldEnum]


  export const TurmaScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type TurmaScalarFieldEnum = (typeof TurmaScalarFieldEnum)[keyof typeof TurmaScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    grupo_id: 'grupo_id',
    senha: 'senha',
    matricula: 'matricula',
    active: 'active'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type alunoWhereInput = {
    AND?: alunoWhereInput | alunoWhereInput[]
    OR?: alunoWhereInput[]
    NOT?: alunoWhereInput | alunoWhereInput[]
    id?: IntFilter<"aluno"> | number
    usuario_id?: IntFilter<"aluno"> | number
    turma_id?: IntFilter<"aluno"> | number
    turma?: XOR<TurmaRelationFilter, turmaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    feito?: FeitoListRelationFilter
  }

  export type alunoOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    turma_id?: SortOrder
    turma?: turmaOrderByWithRelationInput
    usuario?: usuarioOrderByWithRelationInput
    feito?: feitoOrderByRelationAggregateInput
  }

  export type alunoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    id_usuario_id_turma_id?: alunoIdUsuario_idTurma_idCompoundUniqueInput
    AND?: alunoWhereInput | alunoWhereInput[]
    OR?: alunoWhereInput[]
    NOT?: alunoWhereInput | alunoWhereInput[]
    usuario_id?: IntFilter<"aluno"> | number
    turma_id?: IntFilter<"aluno"> | number
    turma?: XOR<TurmaRelationFilter, turmaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    feito?: FeitoListRelationFilter
  }, "id_usuario_id_turma_id" | "id">

  export type alunoOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    turma_id?: SortOrder
    _count?: alunoCountOrderByAggregateInput
    _avg?: alunoAvgOrderByAggregateInput
    _max?: alunoMaxOrderByAggregateInput
    _min?: alunoMinOrderByAggregateInput
    _sum?: alunoSumOrderByAggregateInput
  }

  export type alunoScalarWhereWithAggregatesInput = {
    AND?: alunoScalarWhereWithAggregatesInput | alunoScalarWhereWithAggregatesInput[]
    OR?: alunoScalarWhereWithAggregatesInput[]
    NOT?: alunoScalarWhereWithAggregatesInput | alunoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"aluno"> | number
    usuario_id?: IntWithAggregatesFilter<"aluno"> | number
    turma_id?: IntWithAggregatesFilter<"aluno"> | number
  }

  export type aulaWhereInput = {
    AND?: aulaWhereInput | aulaWhereInput[]
    OR?: aulaWhereInput[]
    NOT?: aulaWhereInput | aulaWhereInput[]
    id?: IntFilter<"aula"> | number
    modulo_id?: IntFilter<"aula"> | number
    titulo?: StringNullableFilter<"aula"> | string | null
    video?: StringFilter<"aula"> | string
    pdf_questoes?: StringNullableFilter<"aula"> | string | null
    pdf_resolucao?: StringNullableFilter<"aula"> | string | null
    descricao?: StringNullableFilter<"aula"> | string | null
    modulo?: XOR<ModuloRelationFilter, moduloWhereInput>
    feito?: FeitoListRelationFilter
  }

  export type aulaOrderByWithRelationInput = {
    id?: SortOrder
    modulo_id?: SortOrder
    titulo?: SortOrderInput | SortOrder
    video?: SortOrder
    pdf_questoes?: SortOrderInput | SortOrder
    pdf_resolucao?: SortOrderInput | SortOrder
    descricao?: SortOrderInput | SortOrder
    modulo?: moduloOrderByWithRelationInput
    feito?: feitoOrderByRelationAggregateInput
  }

  export type aulaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    id_modulo_id?: aulaIdModulo_idCompoundUniqueInput
    AND?: aulaWhereInput | aulaWhereInput[]
    OR?: aulaWhereInput[]
    NOT?: aulaWhereInput | aulaWhereInput[]
    modulo_id?: IntFilter<"aula"> | number
    titulo?: StringNullableFilter<"aula"> | string | null
    video?: StringFilter<"aula"> | string
    pdf_questoes?: StringNullableFilter<"aula"> | string | null
    pdf_resolucao?: StringNullableFilter<"aula"> | string | null
    descricao?: StringNullableFilter<"aula"> | string | null
    modulo?: XOR<ModuloRelationFilter, moduloWhereInput>
    feito?: FeitoListRelationFilter
  }, "id_modulo_id" | "id">

  export type aulaOrderByWithAggregationInput = {
    id?: SortOrder
    modulo_id?: SortOrder
    titulo?: SortOrderInput | SortOrder
    video?: SortOrder
    pdf_questoes?: SortOrderInput | SortOrder
    pdf_resolucao?: SortOrderInput | SortOrder
    descricao?: SortOrderInput | SortOrder
    _count?: aulaCountOrderByAggregateInput
    _avg?: aulaAvgOrderByAggregateInput
    _max?: aulaMaxOrderByAggregateInput
    _min?: aulaMinOrderByAggregateInput
    _sum?: aulaSumOrderByAggregateInput
  }

  export type aulaScalarWhereWithAggregatesInput = {
    AND?: aulaScalarWhereWithAggregatesInput | aulaScalarWhereWithAggregatesInput[]
    OR?: aulaScalarWhereWithAggregatesInput[]
    NOT?: aulaScalarWhereWithAggregatesInput | aulaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"aula"> | number
    modulo_id?: IntWithAggregatesFilter<"aula"> | number
    titulo?: StringNullableWithAggregatesFilter<"aula"> | string | null
    video?: StringWithAggregatesFilter<"aula"> | string
    pdf_questoes?: StringNullableWithAggregatesFilter<"aula"> | string | null
    pdf_resolucao?: StringNullableWithAggregatesFilter<"aula"> | string | null
    descricao?: StringNullableWithAggregatesFilter<"aula"> | string | null
  }

  export type feitoWhereInput = {
    AND?: feitoWhereInput | feitoWhereInput[]
    OR?: feitoWhereInput[]
    NOT?: feitoWhereInput | feitoWhereInput[]
    id?: IntFilter<"feito"> | number
    feito?: BoolNullableFilter<"feito"> | boolean | null
    revisar?: BoolNullableFilter<"feito"> | boolean | null
    aula_id?: IntFilter<"feito"> | number
    aluno_id?: IntFilter<"feito"> | number
    aluno?: XOR<AlunoRelationFilter, alunoWhereInput>
    aula?: XOR<AulaRelationFilter, aulaWhereInput>
  }

  export type feitoOrderByWithRelationInput = {
    id?: SortOrder
    feito?: SortOrderInput | SortOrder
    revisar?: SortOrderInput | SortOrder
    aula_id?: SortOrder
    aluno_id?: SortOrder
    aluno?: alunoOrderByWithRelationInput
    aula?: aulaOrderByWithRelationInput
  }

  export type feitoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: feitoWhereInput | feitoWhereInput[]
    OR?: feitoWhereInput[]
    NOT?: feitoWhereInput | feitoWhereInput[]
    feito?: BoolNullableFilter<"feito"> | boolean | null
    revisar?: BoolNullableFilter<"feito"> | boolean | null
    aula_id?: IntFilter<"feito"> | number
    aluno_id?: IntFilter<"feito"> | number
    aluno?: XOR<AlunoRelationFilter, alunoWhereInput>
    aula?: XOR<AulaRelationFilter, aulaWhereInput>
  }, "id" | "id">

  export type feitoOrderByWithAggregationInput = {
    id?: SortOrder
    feito?: SortOrderInput | SortOrder
    revisar?: SortOrderInput | SortOrder
    aula_id?: SortOrder
    aluno_id?: SortOrder
    _count?: feitoCountOrderByAggregateInput
    _avg?: feitoAvgOrderByAggregateInput
    _max?: feitoMaxOrderByAggregateInput
    _min?: feitoMinOrderByAggregateInput
    _sum?: feitoSumOrderByAggregateInput
  }

  export type feitoScalarWhereWithAggregatesInput = {
    AND?: feitoScalarWhereWithAggregatesInput | feitoScalarWhereWithAggregatesInput[]
    OR?: feitoScalarWhereWithAggregatesInput[]
    NOT?: feitoScalarWhereWithAggregatesInput | feitoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"feito"> | number
    feito?: BoolNullableWithAggregatesFilter<"feito"> | boolean | null
    revisar?: BoolNullableWithAggregatesFilter<"feito"> | boolean | null
    aula_id?: IntWithAggregatesFilter<"feito"> | number
    aluno_id?: IntWithAggregatesFilter<"feito"> | number
  }

  export type grupoWhereInput = {
    AND?: grupoWhereInput | grupoWhereInput[]
    OR?: grupoWhereInput[]
    NOT?: grupoWhereInput | grupoWhereInput[]
    id?: IntFilter<"grupo"> | number
    nome?: StringFilter<"grupo"> | string
    permissoes?: PermissoesListRelationFilter
    usuario?: UsuarioListRelationFilter
  }

  export type grupoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    permissoes?: permissoesOrderByRelationAggregateInput
    usuario?: usuarioOrderByRelationAggregateInput
  }

  export type grupoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: grupoWhereInput | grupoWhereInput[]
    OR?: grupoWhereInput[]
    NOT?: grupoWhereInput | grupoWhereInput[]
    nome?: StringFilter<"grupo"> | string
    permissoes?: PermissoesListRelationFilter
    usuario?: UsuarioListRelationFilter
  }, "id" | "id">

  export type grupoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: grupoCountOrderByAggregateInput
    _avg?: grupoAvgOrderByAggregateInput
    _max?: grupoMaxOrderByAggregateInput
    _min?: grupoMinOrderByAggregateInput
    _sum?: grupoSumOrderByAggregateInput
  }

  export type grupoScalarWhereWithAggregatesInput = {
    AND?: grupoScalarWhereWithAggregatesInput | grupoScalarWhereWithAggregatesInput[]
    OR?: grupoScalarWhereWithAggregatesInput[]
    NOT?: grupoScalarWhereWithAggregatesInput | grupoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"grupo"> | number
    nome?: StringWithAggregatesFilter<"grupo"> | string
  }

  export type moduloWhereInput = {
    AND?: moduloWhereInput | moduloWhereInput[]
    OR?: moduloWhereInput[]
    NOT?: moduloWhereInput | moduloWhereInput[]
    id?: IntFilter<"modulo"> | number
    turma_id?: IntFilter<"modulo"> | number
    titulo?: StringFilter<"modulo"> | string
    image?: StringNullableFilter<"modulo"> | string | null
    descricao?: StringNullableFilter<"modulo"> | string | null
    aula?: AulaListRelationFilter
    turma?: XOR<TurmaRelationFilter, turmaWhereInput>
  }

  export type moduloOrderByWithRelationInput = {
    id?: SortOrder
    turma_id?: SortOrder
    titulo?: SortOrder
    image?: SortOrderInput | SortOrder
    descricao?: SortOrderInput | SortOrder
    aula?: aulaOrderByRelationAggregateInput
    turma?: turmaOrderByWithRelationInput
  }

  export type moduloWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    id_turma_id?: moduloIdTurma_idCompoundUniqueInput
    AND?: moduloWhereInput | moduloWhereInput[]
    OR?: moduloWhereInput[]
    NOT?: moduloWhereInput | moduloWhereInput[]
    turma_id?: IntFilter<"modulo"> | number
    titulo?: StringFilter<"modulo"> | string
    image?: StringNullableFilter<"modulo"> | string | null
    descricao?: StringNullableFilter<"modulo"> | string | null
    aula?: AulaListRelationFilter
    turma?: XOR<TurmaRelationFilter, turmaWhereInput>
  }, "id_turma_id" | "id">

  export type moduloOrderByWithAggregationInput = {
    id?: SortOrder
    turma_id?: SortOrder
    titulo?: SortOrder
    image?: SortOrderInput | SortOrder
    descricao?: SortOrderInput | SortOrder
    _count?: moduloCountOrderByAggregateInput
    _avg?: moduloAvgOrderByAggregateInput
    _max?: moduloMaxOrderByAggregateInput
    _min?: moduloMinOrderByAggregateInput
    _sum?: moduloSumOrderByAggregateInput
  }

  export type moduloScalarWhereWithAggregatesInput = {
    AND?: moduloScalarWhereWithAggregatesInput | moduloScalarWhereWithAggregatesInput[]
    OR?: moduloScalarWhereWithAggregatesInput[]
    NOT?: moduloScalarWhereWithAggregatesInput | moduloScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"modulo"> | number
    turma_id?: IntWithAggregatesFilter<"modulo"> | number
    titulo?: StringWithAggregatesFilter<"modulo"> | string
    image?: StringNullableWithAggregatesFilter<"modulo"> | string | null
    descricao?: StringNullableWithAggregatesFilter<"modulo"> | string | null
  }

  export type permissoesWhereInput = {
    AND?: permissoesWhereInput | permissoesWhereInput[]
    OR?: permissoesWhereInput[]
    NOT?: permissoesWhereInput | permissoesWhereInput[]
    rota_id?: IntFilter<"permissoes"> | number
    grupo_id?: IntFilter<"permissoes"> | number
    grupo?: XOR<GrupoRelationFilter, grupoWhereInput>
    rota?: XOR<RotaRelationFilter, rotaWhereInput>
  }

  export type permissoesOrderByWithRelationInput = {
    rota_id?: SortOrder
    grupo_id?: SortOrder
    grupo?: grupoOrderByWithRelationInput
    rota?: rotaOrderByWithRelationInput
  }

  export type permissoesWhereUniqueInput = Prisma.AtLeast<{
    rota_id_grupo_id?: permissoesRota_idGrupo_idCompoundUniqueInput
    AND?: permissoesWhereInput | permissoesWhereInput[]
    OR?: permissoesWhereInput[]
    NOT?: permissoesWhereInput | permissoesWhereInput[]
    rota_id?: IntFilter<"permissoes"> | number
    grupo_id?: IntFilter<"permissoes"> | number
    grupo?: XOR<GrupoRelationFilter, grupoWhereInput>
    rota?: XOR<RotaRelationFilter, rotaWhereInput>
  }, "rota_id_grupo_id">

  export type permissoesOrderByWithAggregationInput = {
    rota_id?: SortOrder
    grupo_id?: SortOrder
    _count?: permissoesCountOrderByAggregateInput
    _avg?: permissoesAvgOrderByAggregateInput
    _max?: permissoesMaxOrderByAggregateInput
    _min?: permissoesMinOrderByAggregateInput
    _sum?: permissoesSumOrderByAggregateInput
  }

  export type permissoesScalarWhereWithAggregatesInput = {
    AND?: permissoesScalarWhereWithAggregatesInput | permissoesScalarWhereWithAggregatesInput[]
    OR?: permissoesScalarWhereWithAggregatesInput[]
    NOT?: permissoesScalarWhereWithAggregatesInput | permissoesScalarWhereWithAggregatesInput[]
    rota_id?: IntWithAggregatesFilter<"permissoes"> | number
    grupo_id?: IntWithAggregatesFilter<"permissoes"> | number
  }

  export type professorWhereInput = {
    AND?: professorWhereInput | professorWhereInput[]
    OR?: professorWhereInput[]
    NOT?: professorWhereInput | professorWhereInput[]
    id?: IntFilter<"professor"> | number
    turma_id?: IntFilter<"professor"> | number
    usuario_id?: IntFilter<"professor"> | number
    turma?: XOR<TurmaRelationFilter, turmaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
  }

  export type professorOrderByWithRelationInput = {
    id?: SortOrder
    turma_id?: SortOrder
    usuario_id?: SortOrder
    turma?: turmaOrderByWithRelationInput
    usuario?: usuarioOrderByWithRelationInput
  }

  export type professorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    id_turma_id_usuario_id?: professorIdTurma_idUsuario_idCompoundUniqueInput
    AND?: professorWhereInput | professorWhereInput[]
    OR?: professorWhereInput[]
    NOT?: professorWhereInput | professorWhereInput[]
    turma_id?: IntFilter<"professor"> | number
    usuario_id?: IntFilter<"professor"> | number
    turma?: XOR<TurmaRelationFilter, turmaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
  }, "id_turma_id_usuario_id" | "id">

  export type professorOrderByWithAggregationInput = {
    id?: SortOrder
    turma_id?: SortOrder
    usuario_id?: SortOrder
    _count?: professorCountOrderByAggregateInput
    _avg?: professorAvgOrderByAggregateInput
    _max?: professorMaxOrderByAggregateInput
    _min?: professorMinOrderByAggregateInput
    _sum?: professorSumOrderByAggregateInput
  }

  export type professorScalarWhereWithAggregatesInput = {
    AND?: professorScalarWhereWithAggregatesInput | professorScalarWhereWithAggregatesInput[]
    OR?: professorScalarWhereWithAggregatesInput[]
    NOT?: professorScalarWhereWithAggregatesInput | professorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"professor"> | number
    turma_id?: IntWithAggregatesFilter<"professor"> | number
    usuario_id?: IntWithAggregatesFilter<"professor"> | number
  }

  export type rotaWhereInput = {
    AND?: rotaWhereInput | rotaWhereInput[]
    OR?: rotaWhereInput[]
    NOT?: rotaWhereInput | rotaWhereInput[]
    id?: IntFilter<"rota"> | number
    rota?: StringFilter<"rota"> | string
    get?: BoolFilter<"rota"> | boolean
    post?: BoolFilter<"rota"> | boolean
    patch?: BoolFilter<"rota"> | boolean
    put?: BoolFilter<"rota"> | boolean
    delete?: BoolFilter<"rota"> | boolean
    permissoes?: PermissoesListRelationFilter
  }

  export type rotaOrderByWithRelationInput = {
    id?: SortOrder
    rota?: SortOrder
    get?: SortOrder
    post?: SortOrder
    patch?: SortOrder
    put?: SortOrder
    delete?: SortOrder
    permissoes?: permissoesOrderByRelationAggregateInput
  }

  export type rotaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: rotaWhereInput | rotaWhereInput[]
    OR?: rotaWhereInput[]
    NOT?: rotaWhereInput | rotaWhereInput[]
    rota?: StringFilter<"rota"> | string
    get?: BoolFilter<"rota"> | boolean
    post?: BoolFilter<"rota"> | boolean
    patch?: BoolFilter<"rota"> | boolean
    put?: BoolFilter<"rota"> | boolean
    delete?: BoolFilter<"rota"> | boolean
    permissoes?: PermissoesListRelationFilter
  }, "id" | "id">

  export type rotaOrderByWithAggregationInput = {
    id?: SortOrder
    rota?: SortOrder
    get?: SortOrder
    post?: SortOrder
    patch?: SortOrder
    put?: SortOrder
    delete?: SortOrder
    _count?: rotaCountOrderByAggregateInput
    _avg?: rotaAvgOrderByAggregateInput
    _max?: rotaMaxOrderByAggregateInput
    _min?: rotaMinOrderByAggregateInput
    _sum?: rotaSumOrderByAggregateInput
  }

  export type rotaScalarWhereWithAggregatesInput = {
    AND?: rotaScalarWhereWithAggregatesInput | rotaScalarWhereWithAggregatesInput[]
    OR?: rotaScalarWhereWithAggregatesInput[]
    NOT?: rotaScalarWhereWithAggregatesInput | rotaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"rota"> | number
    rota?: StringWithAggregatesFilter<"rota"> | string
    get?: BoolWithAggregatesFilter<"rota"> | boolean
    post?: BoolWithAggregatesFilter<"rota"> | boolean
    patch?: BoolWithAggregatesFilter<"rota"> | boolean
    put?: BoolWithAggregatesFilter<"rota"> | boolean
    delete?: BoolWithAggregatesFilter<"rota"> | boolean
  }

  export type turmaWhereInput = {
    AND?: turmaWhereInput | turmaWhereInput[]
    OR?: turmaWhereInput[]
    NOT?: turmaWhereInput | turmaWhereInput[]
    id?: IntFilter<"turma"> | number
    nome?: StringFilter<"turma"> | string
    aluno?: AlunoListRelationFilter
    modulo?: ModuloListRelationFilter
    professor?: ProfessorListRelationFilter
  }

  export type turmaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    aluno?: alunoOrderByRelationAggregateInput
    modulo?: moduloOrderByRelationAggregateInput
    professor?: professorOrderByRelationAggregateInput
  }

  export type turmaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: turmaWhereInput | turmaWhereInput[]
    OR?: turmaWhereInput[]
    NOT?: turmaWhereInput | turmaWhereInput[]
    nome?: StringFilter<"turma"> | string
    aluno?: AlunoListRelationFilter
    modulo?: ModuloListRelationFilter
    professor?: ProfessorListRelationFilter
  }, "id" | "id">

  export type turmaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: turmaCountOrderByAggregateInput
    _avg?: turmaAvgOrderByAggregateInput
    _max?: turmaMaxOrderByAggregateInput
    _min?: turmaMinOrderByAggregateInput
    _sum?: turmaSumOrderByAggregateInput
  }

  export type turmaScalarWhereWithAggregatesInput = {
    AND?: turmaScalarWhereWithAggregatesInput | turmaScalarWhereWithAggregatesInput[]
    OR?: turmaScalarWhereWithAggregatesInput[]
    NOT?: turmaScalarWhereWithAggregatesInput | turmaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"turma"> | number
    nome?: StringWithAggregatesFilter<"turma"> | string
  }

  export type usuarioWhereInput = {
    AND?: usuarioWhereInput | usuarioWhereInput[]
    OR?: usuarioWhereInput[]
    NOT?: usuarioWhereInput | usuarioWhereInput[]
    id?: IntFilter<"usuario"> | number
    nome?: StringFilter<"usuario"> | string
    grupo_id?: IntFilter<"usuario"> | number
    senha?: StringFilter<"usuario"> | string
    matricula?: StringFilter<"usuario"> | string
    active?: BoolFilter<"usuario"> | boolean
    aluno?: AlunoListRelationFilter
    professor?: ProfessorListRelationFilter
    grupo?: XOR<GrupoRelationFilter, grupoWhereInput>
  }

  export type usuarioOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    grupo_id?: SortOrder
    senha?: SortOrder
    matricula?: SortOrder
    active?: SortOrder
    aluno?: alunoOrderByRelationAggregateInput
    professor?: professorOrderByRelationAggregateInput
    grupo?: grupoOrderByWithRelationInput
  }

  export type usuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    matricula?: string
    id_grupo_id?: usuarioIdGrupo_idCompoundUniqueInput
    AND?: usuarioWhereInput | usuarioWhereInput[]
    OR?: usuarioWhereInput[]
    NOT?: usuarioWhereInput | usuarioWhereInput[]
    nome?: StringFilter<"usuario"> | string
    grupo_id?: IntFilter<"usuario"> | number
    senha?: StringFilter<"usuario"> | string
    active?: BoolFilter<"usuario"> | boolean
    aluno?: AlunoListRelationFilter
    professor?: ProfessorListRelationFilter
    grupo?: XOR<GrupoRelationFilter, grupoWhereInput>
  }, "id_grupo_id" | "id" | "matricula">

  export type usuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    grupo_id?: SortOrder
    senha?: SortOrder
    matricula?: SortOrder
    active?: SortOrder
    _count?: usuarioCountOrderByAggregateInput
    _avg?: usuarioAvgOrderByAggregateInput
    _max?: usuarioMaxOrderByAggregateInput
    _min?: usuarioMinOrderByAggregateInput
    _sum?: usuarioSumOrderByAggregateInput
  }

  export type usuarioScalarWhereWithAggregatesInput = {
    AND?: usuarioScalarWhereWithAggregatesInput | usuarioScalarWhereWithAggregatesInput[]
    OR?: usuarioScalarWhereWithAggregatesInput[]
    NOT?: usuarioScalarWhereWithAggregatesInput | usuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"usuario"> | number
    nome?: StringWithAggregatesFilter<"usuario"> | string
    grupo_id?: IntWithAggregatesFilter<"usuario"> | number
    senha?: StringWithAggregatesFilter<"usuario"> | string
    matricula?: StringWithAggregatesFilter<"usuario"> | string
    active?: BoolWithAggregatesFilter<"usuario"> | boolean
  }

  export type alunoCreateInput = {
    id?: number
    turma: turmaCreateNestedOneWithoutAlunoInput
    usuario: usuarioCreateNestedOneWithoutAlunoInput
    feito?: feitoCreateNestedManyWithoutAlunoInput
  }

  export type alunoUncheckedCreateInput = {
    id?: number
    usuario_id: number
    turma_id: number
    feito?: feitoUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type alunoUpdateInput = {
    turma?: turmaUpdateOneRequiredWithoutAlunoNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutAlunoNestedInput
    feito?: feitoUpdateManyWithoutAlunoNestedInput
  }

  export type alunoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    turma_id?: IntFieldUpdateOperationsInput | number
    feito?: feitoUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type alunoCreateManyInput = {
    id?: number
    usuario_id: number
    turma_id: number
  }

  export type alunoUpdateManyMutationInput = {

  }

  export type alunoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    turma_id?: IntFieldUpdateOperationsInput | number
  }

  export type aulaCreateInput = {
    id?: number
    titulo?: string | null
    video: string
    pdf_questoes?: string | null
    pdf_resolucao?: string | null
    descricao?: string | null
    modulo: moduloCreateNestedOneWithoutAulaInput
    feito?: feitoCreateNestedManyWithoutAulaInput
  }

  export type aulaUncheckedCreateInput = {
    id?: number
    modulo_id: number
    titulo?: string | null
    video: string
    pdf_questoes?: string | null
    pdf_resolucao?: string | null
    descricao?: string | null
    feito?: feitoUncheckedCreateNestedManyWithoutAulaInput
  }

  export type aulaUpdateInput = {
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    video?: StringFieldUpdateOperationsInput | string
    pdf_questoes?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    modulo?: moduloUpdateOneRequiredWithoutAulaNestedInput
    feito?: feitoUpdateManyWithoutAulaNestedInput
  }

  export type aulaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    modulo_id?: IntFieldUpdateOperationsInput | number
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    video?: StringFieldUpdateOperationsInput | string
    pdf_questoes?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    feito?: feitoUncheckedUpdateManyWithoutAulaNestedInput
  }

  export type aulaCreateManyInput = {
    id?: number
    modulo_id: number
    titulo?: string | null
    video: string
    pdf_questoes?: string | null
    pdf_resolucao?: string | null
    descricao?: string | null
  }

  export type aulaUpdateManyMutationInput = {
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    video?: StringFieldUpdateOperationsInput | string
    pdf_questoes?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type aulaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    modulo_id?: IntFieldUpdateOperationsInput | number
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    video?: StringFieldUpdateOperationsInput | string
    pdf_questoes?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type feitoCreateInput = {
    feito?: boolean | null
    revisar?: boolean | null
    aluno: alunoCreateNestedOneWithoutFeitoInput
    aula: aulaCreateNestedOneWithoutFeitoInput
  }

  export type feitoUncheckedCreateInput = {
    id?: number
    feito?: boolean | null
    revisar?: boolean | null
    aula_id: number
    aluno_id: number
  }

  export type feitoUpdateInput = {
    feito?: NullableBoolFieldUpdateOperationsInput | boolean | null
    revisar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aluno?: alunoUpdateOneRequiredWithoutFeitoNestedInput
    aula?: aulaUpdateOneRequiredWithoutFeitoNestedInput
  }

  export type feitoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    feito?: NullableBoolFieldUpdateOperationsInput | boolean | null
    revisar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aula_id?: IntFieldUpdateOperationsInput | number
    aluno_id?: IntFieldUpdateOperationsInput | number
  }

  export type feitoCreateManyInput = {
    id?: number
    feito?: boolean | null
    revisar?: boolean | null
    aula_id: number
    aluno_id: number
  }

  export type feitoUpdateManyMutationInput = {
    feito?: NullableBoolFieldUpdateOperationsInput | boolean | null
    revisar?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type feitoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    feito?: NullableBoolFieldUpdateOperationsInput | boolean | null
    revisar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aula_id?: IntFieldUpdateOperationsInput | number
    aluno_id?: IntFieldUpdateOperationsInput | number
  }

  export type grupoCreateInput = {
    nome: string
    permissoes?: permissoesCreateNestedManyWithoutGrupoInput
    usuario?: usuarioCreateNestedManyWithoutGrupoInput
  }

  export type grupoUncheckedCreateInput = {
    id?: number
    nome: string
    permissoes?: permissoesUncheckedCreateNestedManyWithoutGrupoInput
    usuario?: usuarioUncheckedCreateNestedManyWithoutGrupoInput
  }

  export type grupoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    permissoes?: permissoesUpdateManyWithoutGrupoNestedInput
    usuario?: usuarioUpdateManyWithoutGrupoNestedInput
  }

  export type grupoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    permissoes?: permissoesUncheckedUpdateManyWithoutGrupoNestedInput
    usuario?: usuarioUncheckedUpdateManyWithoutGrupoNestedInput
  }

  export type grupoCreateManyInput = {
    id?: number
    nome: string
  }

  export type grupoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type grupoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type moduloCreateInput = {
    id?: number
    titulo: string
    image?: string | null
    descricao?: string | null
    aula?: aulaCreateNestedManyWithoutModuloInput
    turma: turmaCreateNestedOneWithoutModuloInput
  }

  export type moduloUncheckedCreateInput = {
    id?: number
    turma_id: number
    titulo: string
    image?: string | null
    descricao?: string | null
    aula?: aulaUncheckedCreateNestedManyWithoutModuloInput
  }

  export type moduloUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    aula?: aulaUpdateManyWithoutModuloNestedInput
    turma?: turmaUpdateOneRequiredWithoutModuloNestedInput
  }

  export type moduloUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    turma_id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    aula?: aulaUncheckedUpdateManyWithoutModuloNestedInput
  }

  export type moduloCreateManyInput = {
    id?: number
    turma_id: number
    titulo: string
    image?: string | null
    descricao?: string | null
  }

  export type moduloUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type moduloUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    turma_id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permissoesCreateInput = {
    grupo: grupoCreateNestedOneWithoutPermissoesInput
    rota: rotaCreateNestedOneWithoutPermissoesInput
  }

  export type permissoesUncheckedCreateInput = {
    rota_id: number
    grupo_id: number
  }

  export type permissoesUpdateInput = {
    grupo?: grupoUpdateOneRequiredWithoutPermissoesNestedInput
    rota?: rotaUpdateOneRequiredWithoutPermissoesNestedInput
  }

  export type permissoesUncheckedUpdateInput = {
    rota_id?: IntFieldUpdateOperationsInput | number
    grupo_id?: IntFieldUpdateOperationsInput | number
  }

  export type permissoesCreateManyInput = {
    rota_id: number
    grupo_id: number
  }

  export type permissoesUpdateManyMutationInput = {

  }

  export type permissoesUncheckedUpdateManyInput = {
    rota_id?: IntFieldUpdateOperationsInput | number
    grupo_id?: IntFieldUpdateOperationsInput | number
  }

  export type professorCreateInput = {
    id?: number
    turma: turmaCreateNestedOneWithoutProfessorInput
    usuario: usuarioCreateNestedOneWithoutProfessorInput
  }

  export type professorUncheckedCreateInput = {
    id?: number
    turma_id: number
    usuario_id: number
  }

  export type professorUpdateInput = {
    turma?: turmaUpdateOneRequiredWithoutProfessorNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutProfessorNestedInput
  }

  export type professorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    turma_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type professorCreateManyInput = {
    id?: number
    turma_id: number
    usuario_id: number
  }

  export type professorUpdateManyMutationInput = {

  }

  export type professorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    turma_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type rotaCreateInput = {
    rota: string
    get: boolean
    post: boolean
    patch: boolean
    put: boolean
    delete: boolean
    permissoes?: permissoesCreateNestedManyWithoutRotaInput
  }

  export type rotaUncheckedCreateInput = {
    id?: number
    rota: string
    get: boolean
    post: boolean
    patch: boolean
    put: boolean
    delete: boolean
    permissoes?: permissoesUncheckedCreateNestedManyWithoutRotaInput
  }

  export type rotaUpdateInput = {
    rota?: StringFieldUpdateOperationsInput | string
    get?: BoolFieldUpdateOperationsInput | boolean
    post?: BoolFieldUpdateOperationsInput | boolean
    patch?: BoolFieldUpdateOperationsInput | boolean
    put?: BoolFieldUpdateOperationsInput | boolean
    delete?: BoolFieldUpdateOperationsInput | boolean
    permissoes?: permissoesUpdateManyWithoutRotaNestedInput
  }

  export type rotaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rota?: StringFieldUpdateOperationsInput | string
    get?: BoolFieldUpdateOperationsInput | boolean
    post?: BoolFieldUpdateOperationsInput | boolean
    patch?: BoolFieldUpdateOperationsInput | boolean
    put?: BoolFieldUpdateOperationsInput | boolean
    delete?: BoolFieldUpdateOperationsInput | boolean
    permissoes?: permissoesUncheckedUpdateManyWithoutRotaNestedInput
  }

  export type rotaCreateManyInput = {
    id?: number
    rota: string
    get: boolean
    post: boolean
    patch: boolean
    put: boolean
    delete: boolean
  }

  export type rotaUpdateManyMutationInput = {
    rota?: StringFieldUpdateOperationsInput | string
    get?: BoolFieldUpdateOperationsInput | boolean
    post?: BoolFieldUpdateOperationsInput | boolean
    patch?: BoolFieldUpdateOperationsInput | boolean
    put?: BoolFieldUpdateOperationsInput | boolean
    delete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type rotaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rota?: StringFieldUpdateOperationsInput | string
    get?: BoolFieldUpdateOperationsInput | boolean
    post?: BoolFieldUpdateOperationsInput | boolean
    patch?: BoolFieldUpdateOperationsInput | boolean
    put?: BoolFieldUpdateOperationsInput | boolean
    delete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type turmaCreateInput = {
    nome: string
    aluno?: alunoCreateNestedManyWithoutTurmaInput
    modulo?: moduloCreateNestedManyWithoutTurmaInput
    professor?: professorCreateNestedManyWithoutTurmaInput
  }

  export type turmaUncheckedCreateInput = {
    id?: number
    nome: string
    aluno?: alunoUncheckedCreateNestedManyWithoutTurmaInput
    modulo?: moduloUncheckedCreateNestedManyWithoutTurmaInput
    professor?: professorUncheckedCreateNestedManyWithoutTurmaInput
  }

  export type turmaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    aluno?: alunoUpdateManyWithoutTurmaNestedInput
    modulo?: moduloUpdateManyWithoutTurmaNestedInput
    professor?: professorUpdateManyWithoutTurmaNestedInput
  }

  export type turmaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    aluno?: alunoUncheckedUpdateManyWithoutTurmaNestedInput
    modulo?: moduloUncheckedUpdateManyWithoutTurmaNestedInput
    professor?: professorUncheckedUpdateManyWithoutTurmaNestedInput
  }

  export type turmaCreateManyInput = {
    id?: number
    nome: string
  }

  export type turmaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type turmaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type usuarioCreateInput = {
    id?: number
    nome: string
    senha: string
    matricula: string
    active: boolean
    aluno?: alunoCreateNestedManyWithoutUsuarioInput
    professor?: professorCreateNestedManyWithoutUsuarioInput
    grupo: grupoCreateNestedOneWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateInput = {
    id?: number
    nome: string
    grupo_id: number
    senha: string
    matricula: string
    active: boolean
    aluno?: alunoUncheckedCreateNestedManyWithoutUsuarioInput
    professor?: professorUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    aluno?: alunoUpdateManyWithoutUsuarioNestedInput
    professor?: professorUpdateManyWithoutUsuarioNestedInput
    grupo?: grupoUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    grupo_id?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    aluno?: alunoUncheckedUpdateManyWithoutUsuarioNestedInput
    professor?: professorUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioCreateManyInput = {
    id?: number
    nome: string
    grupo_id: number
    senha: string
    matricula: string
    active: boolean
  }

  export type usuarioUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    grupo_id?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TurmaRelationFilter = {
    is?: turmaWhereInput
    isNot?: turmaWhereInput
  }

  export type UsuarioRelationFilter = {
    is?: usuarioWhereInput
    isNot?: usuarioWhereInput
  }

  export type FeitoListRelationFilter = {
    every?: feitoWhereInput
    some?: feitoWhereInput
    none?: feitoWhereInput
  }

  export type feitoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type alunoIdUsuario_idTurma_idCompoundUniqueInput = {
    id: number
    usuario_id: number
    turma_id: number
  }

  export type alunoCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    turma_id?: SortOrder
  }

  export type alunoAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    turma_id?: SortOrder
  }

  export type alunoMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    turma_id?: SortOrder
  }

  export type alunoMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    turma_id?: SortOrder
  }

  export type alunoSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    turma_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type ModuloRelationFilter = {
    is?: moduloWhereInput
    isNot?: moduloWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type aulaIdModulo_idCompoundUniqueInput = {
    id: number
    modulo_id: number
  }

  export type aulaCountOrderByAggregateInput = {
    id?: SortOrder
    modulo_id?: SortOrder
    titulo?: SortOrder
    video?: SortOrder
    pdf_questoes?: SortOrder
    pdf_resolucao?: SortOrder
    descricao?: SortOrder
  }

  export type aulaAvgOrderByAggregateInput = {
    id?: SortOrder
    modulo_id?: SortOrder
  }

  export type aulaMaxOrderByAggregateInput = {
    id?: SortOrder
    modulo_id?: SortOrder
    titulo?: SortOrder
    video?: SortOrder
    pdf_questoes?: SortOrder
    pdf_resolucao?: SortOrder
    descricao?: SortOrder
  }

  export type aulaMinOrderByAggregateInput = {
    id?: SortOrder
    modulo_id?: SortOrder
    titulo?: SortOrder
    video?: SortOrder
    pdf_questoes?: SortOrder
    pdf_resolucao?: SortOrder
    descricao?: SortOrder
  }

  export type aulaSumOrderByAggregateInput = {
    id?: SortOrder
    modulo_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type AlunoRelationFilter = {
    is?: alunoWhereInput
    isNot?: alunoWhereInput
  }

  export type AulaRelationFilter = {
    is?: aulaWhereInput
    isNot?: aulaWhereInput
  }

  export type feitoCountOrderByAggregateInput = {
    id?: SortOrder
    feito?: SortOrder
    revisar?: SortOrder
    aula_id?: SortOrder
    aluno_id?: SortOrder
  }

  export type feitoAvgOrderByAggregateInput = {
    id?: SortOrder
    aula_id?: SortOrder
    aluno_id?: SortOrder
  }

  export type feitoMaxOrderByAggregateInput = {
    id?: SortOrder
    feito?: SortOrder
    revisar?: SortOrder
    aula_id?: SortOrder
    aluno_id?: SortOrder
  }

  export type feitoMinOrderByAggregateInput = {
    id?: SortOrder
    feito?: SortOrder
    revisar?: SortOrder
    aula_id?: SortOrder
    aluno_id?: SortOrder
  }

  export type feitoSumOrderByAggregateInput = {
    id?: SortOrder
    aula_id?: SortOrder
    aluno_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type PermissoesListRelationFilter = {
    every?: permissoesWhereInput
    some?: permissoesWhereInput
    none?: permissoesWhereInput
  }

  export type UsuarioListRelationFilter = {
    every?: usuarioWhereInput
    some?: usuarioWhereInput
    none?: usuarioWhereInput
  }

  export type permissoesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type grupoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type grupoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type grupoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type grupoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type grupoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AulaListRelationFilter = {
    every?: aulaWhereInput
    some?: aulaWhereInput
    none?: aulaWhereInput
  }

  export type aulaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type moduloIdTurma_idCompoundUniqueInput = {
    id: number
    turma_id: number
  }

  export type moduloCountOrderByAggregateInput = {
    id?: SortOrder
    turma_id?: SortOrder
    titulo?: SortOrder
    image?: SortOrder
    descricao?: SortOrder
  }

  export type moduloAvgOrderByAggregateInput = {
    id?: SortOrder
    turma_id?: SortOrder
  }

  export type moduloMaxOrderByAggregateInput = {
    id?: SortOrder
    turma_id?: SortOrder
    titulo?: SortOrder
    image?: SortOrder
    descricao?: SortOrder
  }

  export type moduloMinOrderByAggregateInput = {
    id?: SortOrder
    turma_id?: SortOrder
    titulo?: SortOrder
    image?: SortOrder
    descricao?: SortOrder
  }

  export type moduloSumOrderByAggregateInput = {
    id?: SortOrder
    turma_id?: SortOrder
  }

  export type GrupoRelationFilter = {
    is?: grupoWhereInput
    isNot?: grupoWhereInput
  }

  export type RotaRelationFilter = {
    is?: rotaWhereInput
    isNot?: rotaWhereInput
  }

  export type permissoesRota_idGrupo_idCompoundUniqueInput = {
    rota_id: number
    grupo_id: number
  }

  export type permissoesCountOrderByAggregateInput = {
    rota_id?: SortOrder
    grupo_id?: SortOrder
  }

  export type permissoesAvgOrderByAggregateInput = {
    rota_id?: SortOrder
    grupo_id?: SortOrder
  }

  export type permissoesMaxOrderByAggregateInput = {
    rota_id?: SortOrder
    grupo_id?: SortOrder
  }

  export type permissoesMinOrderByAggregateInput = {
    rota_id?: SortOrder
    grupo_id?: SortOrder
  }

  export type permissoesSumOrderByAggregateInput = {
    rota_id?: SortOrder
    grupo_id?: SortOrder
  }

  export type professorIdTurma_idUsuario_idCompoundUniqueInput = {
    id: number
    turma_id: number
    usuario_id: number
  }

  export type professorCountOrderByAggregateInput = {
    id?: SortOrder
    turma_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type professorAvgOrderByAggregateInput = {
    id?: SortOrder
    turma_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type professorMaxOrderByAggregateInput = {
    id?: SortOrder
    turma_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type professorMinOrderByAggregateInput = {
    id?: SortOrder
    turma_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type professorSumOrderByAggregateInput = {
    id?: SortOrder
    turma_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type rotaCountOrderByAggregateInput = {
    id?: SortOrder
    rota?: SortOrder
    get?: SortOrder
    post?: SortOrder
    patch?: SortOrder
    put?: SortOrder
    delete?: SortOrder
  }

  export type rotaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rotaMaxOrderByAggregateInput = {
    id?: SortOrder
    rota?: SortOrder
    get?: SortOrder
    post?: SortOrder
    patch?: SortOrder
    put?: SortOrder
    delete?: SortOrder
  }

  export type rotaMinOrderByAggregateInput = {
    id?: SortOrder
    rota?: SortOrder
    get?: SortOrder
    post?: SortOrder
    patch?: SortOrder
    put?: SortOrder
    delete?: SortOrder
  }

  export type rotaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AlunoListRelationFilter = {
    every?: alunoWhereInput
    some?: alunoWhereInput
    none?: alunoWhereInput
  }

  export type ModuloListRelationFilter = {
    every?: moduloWhereInput
    some?: moduloWhereInput
    none?: moduloWhereInput
  }

  export type ProfessorListRelationFilter = {
    every?: professorWhereInput
    some?: professorWhereInput
    none?: professorWhereInput
  }

  export type alunoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type moduloOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type professorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type turmaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type turmaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type turmaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type turmaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type turmaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuarioIdGrupo_idCompoundUniqueInput = {
    id: number
    grupo_id: number
  }

  export type usuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    grupo_id?: SortOrder
    senha?: SortOrder
    matricula?: SortOrder
    active?: SortOrder
  }

  export type usuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    grupo_id?: SortOrder
  }

  export type usuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    grupo_id?: SortOrder
    senha?: SortOrder
    matricula?: SortOrder
    active?: SortOrder
  }

  export type usuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    grupo_id?: SortOrder
    senha?: SortOrder
    matricula?: SortOrder
    active?: SortOrder
  }

  export type usuarioSumOrderByAggregateInput = {
    id?: SortOrder
    grupo_id?: SortOrder
  }

  export type turmaCreateNestedOneWithoutAlunoInput = {
    create?: XOR<turmaCreateWithoutAlunoInput, turmaUncheckedCreateWithoutAlunoInput>
    connectOrCreate?: turmaCreateOrConnectWithoutAlunoInput
    connect?: turmaWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutAlunoInput = {
    create?: XOR<usuarioCreateWithoutAlunoInput, usuarioUncheckedCreateWithoutAlunoInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutAlunoInput
    connect?: usuarioWhereUniqueInput
  }

  export type feitoCreateNestedManyWithoutAlunoInput = {
    create?: XOR<feitoCreateWithoutAlunoInput, feitoUncheckedCreateWithoutAlunoInput> | feitoCreateWithoutAlunoInput[] | feitoUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: feitoCreateOrConnectWithoutAlunoInput | feitoCreateOrConnectWithoutAlunoInput[]
    createMany?: feitoCreateManyAlunoInputEnvelope
    connect?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
  }

  export type feitoUncheckedCreateNestedManyWithoutAlunoInput = {
    create?: XOR<feitoCreateWithoutAlunoInput, feitoUncheckedCreateWithoutAlunoInput> | feitoCreateWithoutAlunoInput[] | feitoUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: feitoCreateOrConnectWithoutAlunoInput | feitoCreateOrConnectWithoutAlunoInput[]
    createMany?: feitoCreateManyAlunoInputEnvelope
    connect?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
  }

  export type turmaUpdateOneRequiredWithoutAlunoNestedInput = {
    create?: XOR<turmaCreateWithoutAlunoInput, turmaUncheckedCreateWithoutAlunoInput>
    connectOrCreate?: turmaCreateOrConnectWithoutAlunoInput
    upsert?: turmaUpsertWithoutAlunoInput
    connect?: turmaWhereUniqueInput
    update?: XOR<XOR<turmaUpdateToOneWithWhereWithoutAlunoInput, turmaUpdateWithoutAlunoInput>, turmaUncheckedUpdateWithoutAlunoInput>
  }

  export type usuarioUpdateOneRequiredWithoutAlunoNestedInput = {
    create?: XOR<usuarioCreateWithoutAlunoInput, usuarioUncheckedCreateWithoutAlunoInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutAlunoInput
    upsert?: usuarioUpsertWithoutAlunoInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutAlunoInput, usuarioUpdateWithoutAlunoInput>, usuarioUncheckedUpdateWithoutAlunoInput>
  }

  export type feitoUpdateManyWithoutAlunoNestedInput = {
    create?: XOR<feitoCreateWithoutAlunoInput, feitoUncheckedCreateWithoutAlunoInput> | feitoCreateWithoutAlunoInput[] | feitoUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: feitoCreateOrConnectWithoutAlunoInput | feitoCreateOrConnectWithoutAlunoInput[]
    upsert?: feitoUpsertWithWhereUniqueWithoutAlunoInput | feitoUpsertWithWhereUniqueWithoutAlunoInput[]
    createMany?: feitoCreateManyAlunoInputEnvelope
    set?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    disconnect?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    delete?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    connect?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    update?: feitoUpdateWithWhereUniqueWithoutAlunoInput | feitoUpdateWithWhereUniqueWithoutAlunoInput[]
    updateMany?: feitoUpdateManyWithWhereWithoutAlunoInput | feitoUpdateManyWithWhereWithoutAlunoInput[]
    deleteMany?: feitoScalarWhereInput | feitoScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type feitoUncheckedUpdateManyWithoutAlunoNestedInput = {
    create?: XOR<feitoCreateWithoutAlunoInput, feitoUncheckedCreateWithoutAlunoInput> | feitoCreateWithoutAlunoInput[] | feitoUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: feitoCreateOrConnectWithoutAlunoInput | feitoCreateOrConnectWithoutAlunoInput[]
    upsert?: feitoUpsertWithWhereUniqueWithoutAlunoInput | feitoUpsertWithWhereUniqueWithoutAlunoInput[]
    createMany?: feitoCreateManyAlunoInputEnvelope
    set?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    disconnect?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    delete?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    connect?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    update?: feitoUpdateWithWhereUniqueWithoutAlunoInput | feitoUpdateWithWhereUniqueWithoutAlunoInput[]
    updateMany?: feitoUpdateManyWithWhereWithoutAlunoInput | feitoUpdateManyWithWhereWithoutAlunoInput[]
    deleteMany?: feitoScalarWhereInput | feitoScalarWhereInput[]
  }

  export type moduloCreateNestedOneWithoutAulaInput = {
    create?: XOR<moduloCreateWithoutAulaInput, moduloUncheckedCreateWithoutAulaInput>
    connectOrCreate?: moduloCreateOrConnectWithoutAulaInput
    connect?: moduloWhereUniqueInput
  }

  export type feitoCreateNestedManyWithoutAulaInput = {
    create?: XOR<feitoCreateWithoutAulaInput, feitoUncheckedCreateWithoutAulaInput> | feitoCreateWithoutAulaInput[] | feitoUncheckedCreateWithoutAulaInput[]
    connectOrCreate?: feitoCreateOrConnectWithoutAulaInput | feitoCreateOrConnectWithoutAulaInput[]
    createMany?: feitoCreateManyAulaInputEnvelope
    connect?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
  }

  export type feitoUncheckedCreateNestedManyWithoutAulaInput = {
    create?: XOR<feitoCreateWithoutAulaInput, feitoUncheckedCreateWithoutAulaInput> | feitoCreateWithoutAulaInput[] | feitoUncheckedCreateWithoutAulaInput[]
    connectOrCreate?: feitoCreateOrConnectWithoutAulaInput | feitoCreateOrConnectWithoutAulaInput[]
    createMany?: feitoCreateManyAulaInputEnvelope
    connect?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type moduloUpdateOneRequiredWithoutAulaNestedInput = {
    create?: XOR<moduloCreateWithoutAulaInput, moduloUncheckedCreateWithoutAulaInput>
    connectOrCreate?: moduloCreateOrConnectWithoutAulaInput
    upsert?: moduloUpsertWithoutAulaInput
    connect?: moduloWhereUniqueInput
    update?: XOR<XOR<moduloUpdateToOneWithWhereWithoutAulaInput, moduloUpdateWithoutAulaInput>, moduloUncheckedUpdateWithoutAulaInput>
  }

  export type feitoUpdateManyWithoutAulaNestedInput = {
    create?: XOR<feitoCreateWithoutAulaInput, feitoUncheckedCreateWithoutAulaInput> | feitoCreateWithoutAulaInput[] | feitoUncheckedCreateWithoutAulaInput[]
    connectOrCreate?: feitoCreateOrConnectWithoutAulaInput | feitoCreateOrConnectWithoutAulaInput[]
    upsert?: feitoUpsertWithWhereUniqueWithoutAulaInput | feitoUpsertWithWhereUniqueWithoutAulaInput[]
    createMany?: feitoCreateManyAulaInputEnvelope
    set?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    disconnect?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    delete?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    connect?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    update?: feitoUpdateWithWhereUniqueWithoutAulaInput | feitoUpdateWithWhereUniqueWithoutAulaInput[]
    updateMany?: feitoUpdateManyWithWhereWithoutAulaInput | feitoUpdateManyWithWhereWithoutAulaInput[]
    deleteMany?: feitoScalarWhereInput | feitoScalarWhereInput[]
  }

  export type feitoUncheckedUpdateManyWithoutAulaNestedInput = {
    create?: XOR<feitoCreateWithoutAulaInput, feitoUncheckedCreateWithoutAulaInput> | feitoCreateWithoutAulaInput[] | feitoUncheckedCreateWithoutAulaInput[]
    connectOrCreate?: feitoCreateOrConnectWithoutAulaInput | feitoCreateOrConnectWithoutAulaInput[]
    upsert?: feitoUpsertWithWhereUniqueWithoutAulaInput | feitoUpsertWithWhereUniqueWithoutAulaInput[]
    createMany?: feitoCreateManyAulaInputEnvelope
    set?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    disconnect?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    delete?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    connect?: feitoWhereUniqueInput | feitoWhereUniqueInput[]
    update?: feitoUpdateWithWhereUniqueWithoutAulaInput | feitoUpdateWithWhereUniqueWithoutAulaInput[]
    updateMany?: feitoUpdateManyWithWhereWithoutAulaInput | feitoUpdateManyWithWhereWithoutAulaInput[]
    deleteMany?: feitoScalarWhereInput | feitoScalarWhereInput[]
  }

  export type alunoCreateNestedOneWithoutFeitoInput = {
    create?: XOR<alunoCreateWithoutFeitoInput, alunoUncheckedCreateWithoutFeitoInput>
    connectOrCreate?: alunoCreateOrConnectWithoutFeitoInput
    connect?: alunoWhereUniqueInput
  }

  export type aulaCreateNestedOneWithoutFeitoInput = {
    create?: XOR<aulaCreateWithoutFeitoInput, aulaUncheckedCreateWithoutFeitoInput>
    connectOrCreate?: aulaCreateOrConnectWithoutFeitoInput
    connect?: aulaWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type alunoUpdateOneRequiredWithoutFeitoNestedInput = {
    create?: XOR<alunoCreateWithoutFeitoInput, alunoUncheckedCreateWithoutFeitoInput>
    connectOrCreate?: alunoCreateOrConnectWithoutFeitoInput
    upsert?: alunoUpsertWithoutFeitoInput
    connect?: alunoWhereUniqueInput
    update?: XOR<XOR<alunoUpdateToOneWithWhereWithoutFeitoInput, alunoUpdateWithoutFeitoInput>, alunoUncheckedUpdateWithoutFeitoInput>
  }

  export type aulaUpdateOneRequiredWithoutFeitoNestedInput = {
    create?: XOR<aulaCreateWithoutFeitoInput, aulaUncheckedCreateWithoutFeitoInput>
    connectOrCreate?: aulaCreateOrConnectWithoutFeitoInput
    upsert?: aulaUpsertWithoutFeitoInput
    connect?: aulaWhereUniqueInput
    update?: XOR<XOR<aulaUpdateToOneWithWhereWithoutFeitoInput, aulaUpdateWithoutFeitoInput>, aulaUncheckedUpdateWithoutFeitoInput>
  }

  export type permissoesCreateNestedManyWithoutGrupoInput = {
    create?: XOR<permissoesCreateWithoutGrupoInput, permissoesUncheckedCreateWithoutGrupoInput> | permissoesCreateWithoutGrupoInput[] | permissoesUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: permissoesCreateOrConnectWithoutGrupoInput | permissoesCreateOrConnectWithoutGrupoInput[]
    createMany?: permissoesCreateManyGrupoInputEnvelope
    connect?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
  }

  export type usuarioCreateNestedManyWithoutGrupoInput = {
    create?: XOR<usuarioCreateWithoutGrupoInput, usuarioUncheckedCreateWithoutGrupoInput> | usuarioCreateWithoutGrupoInput[] | usuarioUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutGrupoInput | usuarioCreateOrConnectWithoutGrupoInput[]
    createMany?: usuarioCreateManyGrupoInputEnvelope
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
  }

  export type permissoesUncheckedCreateNestedManyWithoutGrupoInput = {
    create?: XOR<permissoesCreateWithoutGrupoInput, permissoesUncheckedCreateWithoutGrupoInput> | permissoesCreateWithoutGrupoInput[] | permissoesUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: permissoesCreateOrConnectWithoutGrupoInput | permissoesCreateOrConnectWithoutGrupoInput[]
    createMany?: permissoesCreateManyGrupoInputEnvelope
    connect?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
  }

  export type usuarioUncheckedCreateNestedManyWithoutGrupoInput = {
    create?: XOR<usuarioCreateWithoutGrupoInput, usuarioUncheckedCreateWithoutGrupoInput> | usuarioCreateWithoutGrupoInput[] | usuarioUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutGrupoInput | usuarioCreateOrConnectWithoutGrupoInput[]
    createMany?: usuarioCreateManyGrupoInputEnvelope
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
  }

  export type permissoesUpdateManyWithoutGrupoNestedInput = {
    create?: XOR<permissoesCreateWithoutGrupoInput, permissoesUncheckedCreateWithoutGrupoInput> | permissoesCreateWithoutGrupoInput[] | permissoesUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: permissoesCreateOrConnectWithoutGrupoInput | permissoesCreateOrConnectWithoutGrupoInput[]
    upsert?: permissoesUpsertWithWhereUniqueWithoutGrupoInput | permissoesUpsertWithWhereUniqueWithoutGrupoInput[]
    createMany?: permissoesCreateManyGrupoInputEnvelope
    set?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    disconnect?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    delete?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    connect?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    update?: permissoesUpdateWithWhereUniqueWithoutGrupoInput | permissoesUpdateWithWhereUniqueWithoutGrupoInput[]
    updateMany?: permissoesUpdateManyWithWhereWithoutGrupoInput | permissoesUpdateManyWithWhereWithoutGrupoInput[]
    deleteMany?: permissoesScalarWhereInput | permissoesScalarWhereInput[]
  }

  export type usuarioUpdateManyWithoutGrupoNestedInput = {
    create?: XOR<usuarioCreateWithoutGrupoInput, usuarioUncheckedCreateWithoutGrupoInput> | usuarioCreateWithoutGrupoInput[] | usuarioUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutGrupoInput | usuarioCreateOrConnectWithoutGrupoInput[]
    upsert?: usuarioUpsertWithWhereUniqueWithoutGrupoInput | usuarioUpsertWithWhereUniqueWithoutGrupoInput[]
    createMany?: usuarioCreateManyGrupoInputEnvelope
    set?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    disconnect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    delete?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    update?: usuarioUpdateWithWhereUniqueWithoutGrupoInput | usuarioUpdateWithWhereUniqueWithoutGrupoInput[]
    updateMany?: usuarioUpdateManyWithWhereWithoutGrupoInput | usuarioUpdateManyWithWhereWithoutGrupoInput[]
    deleteMany?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
  }

  export type permissoesUncheckedUpdateManyWithoutGrupoNestedInput = {
    create?: XOR<permissoesCreateWithoutGrupoInput, permissoesUncheckedCreateWithoutGrupoInput> | permissoesCreateWithoutGrupoInput[] | permissoesUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: permissoesCreateOrConnectWithoutGrupoInput | permissoesCreateOrConnectWithoutGrupoInput[]
    upsert?: permissoesUpsertWithWhereUniqueWithoutGrupoInput | permissoesUpsertWithWhereUniqueWithoutGrupoInput[]
    createMany?: permissoesCreateManyGrupoInputEnvelope
    set?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    disconnect?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    delete?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    connect?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    update?: permissoesUpdateWithWhereUniqueWithoutGrupoInput | permissoesUpdateWithWhereUniqueWithoutGrupoInput[]
    updateMany?: permissoesUpdateManyWithWhereWithoutGrupoInput | permissoesUpdateManyWithWhereWithoutGrupoInput[]
    deleteMany?: permissoesScalarWhereInput | permissoesScalarWhereInput[]
  }

  export type usuarioUncheckedUpdateManyWithoutGrupoNestedInput = {
    create?: XOR<usuarioCreateWithoutGrupoInput, usuarioUncheckedCreateWithoutGrupoInput> | usuarioCreateWithoutGrupoInput[] | usuarioUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutGrupoInput | usuarioCreateOrConnectWithoutGrupoInput[]
    upsert?: usuarioUpsertWithWhereUniqueWithoutGrupoInput | usuarioUpsertWithWhereUniqueWithoutGrupoInput[]
    createMany?: usuarioCreateManyGrupoInputEnvelope
    set?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    disconnect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    delete?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    update?: usuarioUpdateWithWhereUniqueWithoutGrupoInput | usuarioUpdateWithWhereUniqueWithoutGrupoInput[]
    updateMany?: usuarioUpdateManyWithWhereWithoutGrupoInput | usuarioUpdateManyWithWhereWithoutGrupoInput[]
    deleteMany?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
  }

  export type aulaCreateNestedManyWithoutModuloInput = {
    create?: XOR<aulaCreateWithoutModuloInput, aulaUncheckedCreateWithoutModuloInput> | aulaCreateWithoutModuloInput[] | aulaUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: aulaCreateOrConnectWithoutModuloInput | aulaCreateOrConnectWithoutModuloInput[]
    createMany?: aulaCreateManyModuloInputEnvelope
    connect?: aulaWhereUniqueInput | aulaWhereUniqueInput[]
  }

  export type turmaCreateNestedOneWithoutModuloInput = {
    create?: XOR<turmaCreateWithoutModuloInput, turmaUncheckedCreateWithoutModuloInput>
    connectOrCreate?: turmaCreateOrConnectWithoutModuloInput
    connect?: turmaWhereUniqueInput
  }

  export type aulaUncheckedCreateNestedManyWithoutModuloInput = {
    create?: XOR<aulaCreateWithoutModuloInput, aulaUncheckedCreateWithoutModuloInput> | aulaCreateWithoutModuloInput[] | aulaUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: aulaCreateOrConnectWithoutModuloInput | aulaCreateOrConnectWithoutModuloInput[]
    createMany?: aulaCreateManyModuloInputEnvelope
    connect?: aulaWhereUniqueInput | aulaWhereUniqueInput[]
  }

  export type aulaUpdateManyWithoutModuloNestedInput = {
    create?: XOR<aulaCreateWithoutModuloInput, aulaUncheckedCreateWithoutModuloInput> | aulaCreateWithoutModuloInput[] | aulaUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: aulaCreateOrConnectWithoutModuloInput | aulaCreateOrConnectWithoutModuloInput[]
    upsert?: aulaUpsertWithWhereUniqueWithoutModuloInput | aulaUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: aulaCreateManyModuloInputEnvelope
    set?: aulaWhereUniqueInput | aulaWhereUniqueInput[]
    disconnect?: aulaWhereUniqueInput | aulaWhereUniqueInput[]
    delete?: aulaWhereUniqueInput | aulaWhereUniqueInput[]
    connect?: aulaWhereUniqueInput | aulaWhereUniqueInput[]
    update?: aulaUpdateWithWhereUniqueWithoutModuloInput | aulaUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: aulaUpdateManyWithWhereWithoutModuloInput | aulaUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: aulaScalarWhereInput | aulaScalarWhereInput[]
  }

  export type turmaUpdateOneRequiredWithoutModuloNestedInput = {
    create?: XOR<turmaCreateWithoutModuloInput, turmaUncheckedCreateWithoutModuloInput>
    connectOrCreate?: turmaCreateOrConnectWithoutModuloInput
    upsert?: turmaUpsertWithoutModuloInput
    connect?: turmaWhereUniqueInput
    update?: XOR<XOR<turmaUpdateToOneWithWhereWithoutModuloInput, turmaUpdateWithoutModuloInput>, turmaUncheckedUpdateWithoutModuloInput>
  }

  export type aulaUncheckedUpdateManyWithoutModuloNestedInput = {
    create?: XOR<aulaCreateWithoutModuloInput, aulaUncheckedCreateWithoutModuloInput> | aulaCreateWithoutModuloInput[] | aulaUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: aulaCreateOrConnectWithoutModuloInput | aulaCreateOrConnectWithoutModuloInput[]
    upsert?: aulaUpsertWithWhereUniqueWithoutModuloInput | aulaUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: aulaCreateManyModuloInputEnvelope
    set?: aulaWhereUniqueInput | aulaWhereUniqueInput[]
    disconnect?: aulaWhereUniqueInput | aulaWhereUniqueInput[]
    delete?: aulaWhereUniqueInput | aulaWhereUniqueInput[]
    connect?: aulaWhereUniqueInput | aulaWhereUniqueInput[]
    update?: aulaUpdateWithWhereUniqueWithoutModuloInput | aulaUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: aulaUpdateManyWithWhereWithoutModuloInput | aulaUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: aulaScalarWhereInput | aulaScalarWhereInput[]
  }

  export type grupoCreateNestedOneWithoutPermissoesInput = {
    create?: XOR<grupoCreateWithoutPermissoesInput, grupoUncheckedCreateWithoutPermissoesInput>
    connectOrCreate?: grupoCreateOrConnectWithoutPermissoesInput
    connect?: grupoWhereUniqueInput
  }

  export type rotaCreateNestedOneWithoutPermissoesInput = {
    create?: XOR<rotaCreateWithoutPermissoesInput, rotaUncheckedCreateWithoutPermissoesInput>
    connectOrCreate?: rotaCreateOrConnectWithoutPermissoesInput
    connect?: rotaWhereUniqueInput
  }

  export type grupoUpdateOneRequiredWithoutPermissoesNestedInput = {
    create?: XOR<grupoCreateWithoutPermissoesInput, grupoUncheckedCreateWithoutPermissoesInput>
    connectOrCreate?: grupoCreateOrConnectWithoutPermissoesInput
    upsert?: grupoUpsertWithoutPermissoesInput
    connect?: grupoWhereUniqueInput
    update?: XOR<XOR<grupoUpdateToOneWithWhereWithoutPermissoesInput, grupoUpdateWithoutPermissoesInput>, grupoUncheckedUpdateWithoutPermissoesInput>
  }

  export type rotaUpdateOneRequiredWithoutPermissoesNestedInput = {
    create?: XOR<rotaCreateWithoutPermissoesInput, rotaUncheckedCreateWithoutPermissoesInput>
    connectOrCreate?: rotaCreateOrConnectWithoutPermissoesInput
    upsert?: rotaUpsertWithoutPermissoesInput
    connect?: rotaWhereUniqueInput
    update?: XOR<XOR<rotaUpdateToOneWithWhereWithoutPermissoesInput, rotaUpdateWithoutPermissoesInput>, rotaUncheckedUpdateWithoutPermissoesInput>
  }

  export type turmaCreateNestedOneWithoutProfessorInput = {
    create?: XOR<turmaCreateWithoutProfessorInput, turmaUncheckedCreateWithoutProfessorInput>
    connectOrCreate?: turmaCreateOrConnectWithoutProfessorInput
    connect?: turmaWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutProfessorInput = {
    create?: XOR<usuarioCreateWithoutProfessorInput, usuarioUncheckedCreateWithoutProfessorInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutProfessorInput
    connect?: usuarioWhereUniqueInput
  }

  export type turmaUpdateOneRequiredWithoutProfessorNestedInput = {
    create?: XOR<turmaCreateWithoutProfessorInput, turmaUncheckedCreateWithoutProfessorInput>
    connectOrCreate?: turmaCreateOrConnectWithoutProfessorInput
    upsert?: turmaUpsertWithoutProfessorInput
    connect?: turmaWhereUniqueInput
    update?: XOR<XOR<turmaUpdateToOneWithWhereWithoutProfessorInput, turmaUpdateWithoutProfessorInput>, turmaUncheckedUpdateWithoutProfessorInput>
  }

  export type usuarioUpdateOneRequiredWithoutProfessorNestedInput = {
    create?: XOR<usuarioCreateWithoutProfessorInput, usuarioUncheckedCreateWithoutProfessorInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutProfessorInput
    upsert?: usuarioUpsertWithoutProfessorInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutProfessorInput, usuarioUpdateWithoutProfessorInput>, usuarioUncheckedUpdateWithoutProfessorInput>
  }

  export type permissoesCreateNestedManyWithoutRotaInput = {
    create?: XOR<permissoesCreateWithoutRotaInput, permissoesUncheckedCreateWithoutRotaInput> | permissoesCreateWithoutRotaInput[] | permissoesUncheckedCreateWithoutRotaInput[]
    connectOrCreate?: permissoesCreateOrConnectWithoutRotaInput | permissoesCreateOrConnectWithoutRotaInput[]
    createMany?: permissoesCreateManyRotaInputEnvelope
    connect?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
  }

  export type permissoesUncheckedCreateNestedManyWithoutRotaInput = {
    create?: XOR<permissoesCreateWithoutRotaInput, permissoesUncheckedCreateWithoutRotaInput> | permissoesCreateWithoutRotaInput[] | permissoesUncheckedCreateWithoutRotaInput[]
    connectOrCreate?: permissoesCreateOrConnectWithoutRotaInput | permissoesCreateOrConnectWithoutRotaInput[]
    createMany?: permissoesCreateManyRotaInputEnvelope
    connect?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type permissoesUpdateManyWithoutRotaNestedInput = {
    create?: XOR<permissoesCreateWithoutRotaInput, permissoesUncheckedCreateWithoutRotaInput> | permissoesCreateWithoutRotaInput[] | permissoesUncheckedCreateWithoutRotaInput[]
    connectOrCreate?: permissoesCreateOrConnectWithoutRotaInput | permissoesCreateOrConnectWithoutRotaInput[]
    upsert?: permissoesUpsertWithWhereUniqueWithoutRotaInput | permissoesUpsertWithWhereUniqueWithoutRotaInput[]
    createMany?: permissoesCreateManyRotaInputEnvelope
    set?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    disconnect?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    delete?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    connect?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    update?: permissoesUpdateWithWhereUniqueWithoutRotaInput | permissoesUpdateWithWhereUniqueWithoutRotaInput[]
    updateMany?: permissoesUpdateManyWithWhereWithoutRotaInput | permissoesUpdateManyWithWhereWithoutRotaInput[]
    deleteMany?: permissoesScalarWhereInput | permissoesScalarWhereInput[]
  }

  export type permissoesUncheckedUpdateManyWithoutRotaNestedInput = {
    create?: XOR<permissoesCreateWithoutRotaInput, permissoesUncheckedCreateWithoutRotaInput> | permissoesCreateWithoutRotaInput[] | permissoesUncheckedCreateWithoutRotaInput[]
    connectOrCreate?: permissoesCreateOrConnectWithoutRotaInput | permissoesCreateOrConnectWithoutRotaInput[]
    upsert?: permissoesUpsertWithWhereUniqueWithoutRotaInput | permissoesUpsertWithWhereUniqueWithoutRotaInput[]
    createMany?: permissoesCreateManyRotaInputEnvelope
    set?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    disconnect?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    delete?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    connect?: permissoesWhereUniqueInput | permissoesWhereUniqueInput[]
    update?: permissoesUpdateWithWhereUniqueWithoutRotaInput | permissoesUpdateWithWhereUniqueWithoutRotaInput[]
    updateMany?: permissoesUpdateManyWithWhereWithoutRotaInput | permissoesUpdateManyWithWhereWithoutRotaInput[]
    deleteMany?: permissoesScalarWhereInput | permissoesScalarWhereInput[]
  }

  export type alunoCreateNestedManyWithoutTurmaInput = {
    create?: XOR<alunoCreateWithoutTurmaInput, alunoUncheckedCreateWithoutTurmaInput> | alunoCreateWithoutTurmaInput[] | alunoUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: alunoCreateOrConnectWithoutTurmaInput | alunoCreateOrConnectWithoutTurmaInput[]
    createMany?: alunoCreateManyTurmaInputEnvelope
    connect?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
  }

  export type moduloCreateNestedManyWithoutTurmaInput = {
    create?: XOR<moduloCreateWithoutTurmaInput, moduloUncheckedCreateWithoutTurmaInput> | moduloCreateWithoutTurmaInput[] | moduloUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: moduloCreateOrConnectWithoutTurmaInput | moduloCreateOrConnectWithoutTurmaInput[]
    createMany?: moduloCreateManyTurmaInputEnvelope
    connect?: moduloWhereUniqueInput | moduloWhereUniqueInput[]
  }

  export type professorCreateNestedManyWithoutTurmaInput = {
    create?: XOR<professorCreateWithoutTurmaInput, professorUncheckedCreateWithoutTurmaInput> | professorCreateWithoutTurmaInput[] | professorUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: professorCreateOrConnectWithoutTurmaInput | professorCreateOrConnectWithoutTurmaInput[]
    createMany?: professorCreateManyTurmaInputEnvelope
    connect?: professorWhereUniqueInput | professorWhereUniqueInput[]
  }

  export type alunoUncheckedCreateNestedManyWithoutTurmaInput = {
    create?: XOR<alunoCreateWithoutTurmaInput, alunoUncheckedCreateWithoutTurmaInput> | alunoCreateWithoutTurmaInput[] | alunoUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: alunoCreateOrConnectWithoutTurmaInput | alunoCreateOrConnectWithoutTurmaInput[]
    createMany?: alunoCreateManyTurmaInputEnvelope
    connect?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
  }

  export type moduloUncheckedCreateNestedManyWithoutTurmaInput = {
    create?: XOR<moduloCreateWithoutTurmaInput, moduloUncheckedCreateWithoutTurmaInput> | moduloCreateWithoutTurmaInput[] | moduloUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: moduloCreateOrConnectWithoutTurmaInput | moduloCreateOrConnectWithoutTurmaInput[]
    createMany?: moduloCreateManyTurmaInputEnvelope
    connect?: moduloWhereUniqueInput | moduloWhereUniqueInput[]
  }

  export type professorUncheckedCreateNestedManyWithoutTurmaInput = {
    create?: XOR<professorCreateWithoutTurmaInput, professorUncheckedCreateWithoutTurmaInput> | professorCreateWithoutTurmaInput[] | professorUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: professorCreateOrConnectWithoutTurmaInput | professorCreateOrConnectWithoutTurmaInput[]
    createMany?: professorCreateManyTurmaInputEnvelope
    connect?: professorWhereUniqueInput | professorWhereUniqueInput[]
  }

  export type alunoUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<alunoCreateWithoutTurmaInput, alunoUncheckedCreateWithoutTurmaInput> | alunoCreateWithoutTurmaInput[] | alunoUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: alunoCreateOrConnectWithoutTurmaInput | alunoCreateOrConnectWithoutTurmaInput[]
    upsert?: alunoUpsertWithWhereUniqueWithoutTurmaInput | alunoUpsertWithWhereUniqueWithoutTurmaInput[]
    createMany?: alunoCreateManyTurmaInputEnvelope
    set?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    disconnect?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    delete?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    connect?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    update?: alunoUpdateWithWhereUniqueWithoutTurmaInput | alunoUpdateWithWhereUniqueWithoutTurmaInput[]
    updateMany?: alunoUpdateManyWithWhereWithoutTurmaInput | alunoUpdateManyWithWhereWithoutTurmaInput[]
    deleteMany?: alunoScalarWhereInput | alunoScalarWhereInput[]
  }

  export type moduloUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<moduloCreateWithoutTurmaInput, moduloUncheckedCreateWithoutTurmaInput> | moduloCreateWithoutTurmaInput[] | moduloUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: moduloCreateOrConnectWithoutTurmaInput | moduloCreateOrConnectWithoutTurmaInput[]
    upsert?: moduloUpsertWithWhereUniqueWithoutTurmaInput | moduloUpsertWithWhereUniqueWithoutTurmaInput[]
    createMany?: moduloCreateManyTurmaInputEnvelope
    set?: moduloWhereUniqueInput | moduloWhereUniqueInput[]
    disconnect?: moduloWhereUniqueInput | moduloWhereUniqueInput[]
    delete?: moduloWhereUniqueInput | moduloWhereUniqueInput[]
    connect?: moduloWhereUniqueInput | moduloWhereUniqueInput[]
    update?: moduloUpdateWithWhereUniqueWithoutTurmaInput | moduloUpdateWithWhereUniqueWithoutTurmaInput[]
    updateMany?: moduloUpdateManyWithWhereWithoutTurmaInput | moduloUpdateManyWithWhereWithoutTurmaInput[]
    deleteMany?: moduloScalarWhereInput | moduloScalarWhereInput[]
  }

  export type professorUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<professorCreateWithoutTurmaInput, professorUncheckedCreateWithoutTurmaInput> | professorCreateWithoutTurmaInput[] | professorUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: professorCreateOrConnectWithoutTurmaInput | professorCreateOrConnectWithoutTurmaInput[]
    upsert?: professorUpsertWithWhereUniqueWithoutTurmaInput | professorUpsertWithWhereUniqueWithoutTurmaInput[]
    createMany?: professorCreateManyTurmaInputEnvelope
    set?: professorWhereUniqueInput | professorWhereUniqueInput[]
    disconnect?: professorWhereUniqueInput | professorWhereUniqueInput[]
    delete?: professorWhereUniqueInput | professorWhereUniqueInput[]
    connect?: professorWhereUniqueInput | professorWhereUniqueInput[]
    update?: professorUpdateWithWhereUniqueWithoutTurmaInput | professorUpdateWithWhereUniqueWithoutTurmaInput[]
    updateMany?: professorUpdateManyWithWhereWithoutTurmaInput | professorUpdateManyWithWhereWithoutTurmaInput[]
    deleteMany?: professorScalarWhereInput | professorScalarWhereInput[]
  }

  export type alunoUncheckedUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<alunoCreateWithoutTurmaInput, alunoUncheckedCreateWithoutTurmaInput> | alunoCreateWithoutTurmaInput[] | alunoUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: alunoCreateOrConnectWithoutTurmaInput | alunoCreateOrConnectWithoutTurmaInput[]
    upsert?: alunoUpsertWithWhereUniqueWithoutTurmaInput | alunoUpsertWithWhereUniqueWithoutTurmaInput[]
    createMany?: alunoCreateManyTurmaInputEnvelope
    set?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    disconnect?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    delete?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    connect?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    update?: alunoUpdateWithWhereUniqueWithoutTurmaInput | alunoUpdateWithWhereUniqueWithoutTurmaInput[]
    updateMany?: alunoUpdateManyWithWhereWithoutTurmaInput | alunoUpdateManyWithWhereWithoutTurmaInput[]
    deleteMany?: alunoScalarWhereInput | alunoScalarWhereInput[]
  }

  export type moduloUncheckedUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<moduloCreateWithoutTurmaInput, moduloUncheckedCreateWithoutTurmaInput> | moduloCreateWithoutTurmaInput[] | moduloUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: moduloCreateOrConnectWithoutTurmaInput | moduloCreateOrConnectWithoutTurmaInput[]
    upsert?: moduloUpsertWithWhereUniqueWithoutTurmaInput | moduloUpsertWithWhereUniqueWithoutTurmaInput[]
    createMany?: moduloCreateManyTurmaInputEnvelope
    set?: moduloWhereUniqueInput | moduloWhereUniqueInput[]
    disconnect?: moduloWhereUniqueInput | moduloWhereUniqueInput[]
    delete?: moduloWhereUniqueInput | moduloWhereUniqueInput[]
    connect?: moduloWhereUniqueInput | moduloWhereUniqueInput[]
    update?: moduloUpdateWithWhereUniqueWithoutTurmaInput | moduloUpdateWithWhereUniqueWithoutTurmaInput[]
    updateMany?: moduloUpdateManyWithWhereWithoutTurmaInput | moduloUpdateManyWithWhereWithoutTurmaInput[]
    deleteMany?: moduloScalarWhereInput | moduloScalarWhereInput[]
  }

  export type professorUncheckedUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<professorCreateWithoutTurmaInput, professorUncheckedCreateWithoutTurmaInput> | professorCreateWithoutTurmaInput[] | professorUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: professorCreateOrConnectWithoutTurmaInput | professorCreateOrConnectWithoutTurmaInput[]
    upsert?: professorUpsertWithWhereUniqueWithoutTurmaInput | professorUpsertWithWhereUniqueWithoutTurmaInput[]
    createMany?: professorCreateManyTurmaInputEnvelope
    set?: professorWhereUniqueInput | professorWhereUniqueInput[]
    disconnect?: professorWhereUniqueInput | professorWhereUniqueInput[]
    delete?: professorWhereUniqueInput | professorWhereUniqueInput[]
    connect?: professorWhereUniqueInput | professorWhereUniqueInput[]
    update?: professorUpdateWithWhereUniqueWithoutTurmaInput | professorUpdateWithWhereUniqueWithoutTurmaInput[]
    updateMany?: professorUpdateManyWithWhereWithoutTurmaInput | professorUpdateManyWithWhereWithoutTurmaInput[]
    deleteMany?: professorScalarWhereInput | professorScalarWhereInput[]
  }

  export type alunoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<alunoCreateWithoutUsuarioInput, alunoUncheckedCreateWithoutUsuarioInput> | alunoCreateWithoutUsuarioInput[] | alunoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: alunoCreateOrConnectWithoutUsuarioInput | alunoCreateOrConnectWithoutUsuarioInput[]
    createMany?: alunoCreateManyUsuarioInputEnvelope
    connect?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
  }

  export type professorCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<professorCreateWithoutUsuarioInput, professorUncheckedCreateWithoutUsuarioInput> | professorCreateWithoutUsuarioInput[] | professorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: professorCreateOrConnectWithoutUsuarioInput | professorCreateOrConnectWithoutUsuarioInput[]
    createMany?: professorCreateManyUsuarioInputEnvelope
    connect?: professorWhereUniqueInput | professorWhereUniqueInput[]
  }

  export type grupoCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<grupoCreateWithoutUsuarioInput, grupoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: grupoCreateOrConnectWithoutUsuarioInput
    connect?: grupoWhereUniqueInput
  }

  export type alunoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<alunoCreateWithoutUsuarioInput, alunoUncheckedCreateWithoutUsuarioInput> | alunoCreateWithoutUsuarioInput[] | alunoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: alunoCreateOrConnectWithoutUsuarioInput | alunoCreateOrConnectWithoutUsuarioInput[]
    createMany?: alunoCreateManyUsuarioInputEnvelope
    connect?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
  }

  export type professorUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<professorCreateWithoutUsuarioInput, professorUncheckedCreateWithoutUsuarioInput> | professorCreateWithoutUsuarioInput[] | professorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: professorCreateOrConnectWithoutUsuarioInput | professorCreateOrConnectWithoutUsuarioInput[]
    createMany?: professorCreateManyUsuarioInputEnvelope
    connect?: professorWhereUniqueInput | professorWhereUniqueInput[]
  }

  export type alunoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<alunoCreateWithoutUsuarioInput, alunoUncheckedCreateWithoutUsuarioInput> | alunoCreateWithoutUsuarioInput[] | alunoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: alunoCreateOrConnectWithoutUsuarioInput | alunoCreateOrConnectWithoutUsuarioInput[]
    upsert?: alunoUpsertWithWhereUniqueWithoutUsuarioInput | alunoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: alunoCreateManyUsuarioInputEnvelope
    set?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    disconnect?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    delete?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    connect?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    update?: alunoUpdateWithWhereUniqueWithoutUsuarioInput | alunoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: alunoUpdateManyWithWhereWithoutUsuarioInput | alunoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: alunoScalarWhereInput | alunoScalarWhereInput[]
  }

  export type professorUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<professorCreateWithoutUsuarioInput, professorUncheckedCreateWithoutUsuarioInput> | professorCreateWithoutUsuarioInput[] | professorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: professorCreateOrConnectWithoutUsuarioInput | professorCreateOrConnectWithoutUsuarioInput[]
    upsert?: professorUpsertWithWhereUniqueWithoutUsuarioInput | professorUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: professorCreateManyUsuarioInputEnvelope
    set?: professorWhereUniqueInput | professorWhereUniqueInput[]
    disconnect?: professorWhereUniqueInput | professorWhereUniqueInput[]
    delete?: professorWhereUniqueInput | professorWhereUniqueInput[]
    connect?: professorWhereUniqueInput | professorWhereUniqueInput[]
    update?: professorUpdateWithWhereUniqueWithoutUsuarioInput | professorUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: professorUpdateManyWithWhereWithoutUsuarioInput | professorUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: professorScalarWhereInput | professorScalarWhereInput[]
  }

  export type grupoUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<grupoCreateWithoutUsuarioInput, grupoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: grupoCreateOrConnectWithoutUsuarioInput
    upsert?: grupoUpsertWithoutUsuarioInput
    connect?: grupoWhereUniqueInput
    update?: XOR<XOR<grupoUpdateToOneWithWhereWithoutUsuarioInput, grupoUpdateWithoutUsuarioInput>, grupoUncheckedUpdateWithoutUsuarioInput>
  }

  export type alunoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<alunoCreateWithoutUsuarioInput, alunoUncheckedCreateWithoutUsuarioInput> | alunoCreateWithoutUsuarioInput[] | alunoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: alunoCreateOrConnectWithoutUsuarioInput | alunoCreateOrConnectWithoutUsuarioInput[]
    upsert?: alunoUpsertWithWhereUniqueWithoutUsuarioInput | alunoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: alunoCreateManyUsuarioInputEnvelope
    set?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    disconnect?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    delete?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    connect?: alunoWhereUniqueInput | alunoWhereUniqueInput[]
    update?: alunoUpdateWithWhereUniqueWithoutUsuarioInput | alunoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: alunoUpdateManyWithWhereWithoutUsuarioInput | alunoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: alunoScalarWhereInput | alunoScalarWhereInput[]
  }

  export type professorUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<professorCreateWithoutUsuarioInput, professorUncheckedCreateWithoutUsuarioInput> | professorCreateWithoutUsuarioInput[] | professorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: professorCreateOrConnectWithoutUsuarioInput | professorCreateOrConnectWithoutUsuarioInput[]
    upsert?: professorUpsertWithWhereUniqueWithoutUsuarioInput | professorUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: professorCreateManyUsuarioInputEnvelope
    set?: professorWhereUniqueInput | professorWhereUniqueInput[]
    disconnect?: professorWhereUniqueInput | professorWhereUniqueInput[]
    delete?: professorWhereUniqueInput | professorWhereUniqueInput[]
    connect?: professorWhereUniqueInput | professorWhereUniqueInput[]
    update?: professorUpdateWithWhereUniqueWithoutUsuarioInput | professorUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: professorUpdateManyWithWhereWithoutUsuarioInput | professorUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: professorScalarWhereInput | professorScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type turmaCreateWithoutAlunoInput = {
    nome: string
    modulo?: moduloCreateNestedManyWithoutTurmaInput
    professor?: professorCreateNestedManyWithoutTurmaInput
  }

  export type turmaUncheckedCreateWithoutAlunoInput = {
    id?: number
    nome: string
    modulo?: moduloUncheckedCreateNestedManyWithoutTurmaInput
    professor?: professorUncheckedCreateNestedManyWithoutTurmaInput
  }

  export type turmaCreateOrConnectWithoutAlunoInput = {
    where: turmaWhereUniqueInput
    create: XOR<turmaCreateWithoutAlunoInput, turmaUncheckedCreateWithoutAlunoInput>
  }

  export type usuarioCreateWithoutAlunoInput = {
    id?: number
    nome: string
    senha: string
    matricula: string
    active: boolean
    professor?: professorCreateNestedManyWithoutUsuarioInput
    grupo: grupoCreateNestedOneWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutAlunoInput = {
    id?: number
    nome: string
    grupo_id: number
    senha: string
    matricula: string
    active: boolean
    professor?: professorUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutAlunoInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutAlunoInput, usuarioUncheckedCreateWithoutAlunoInput>
  }

  export type feitoCreateWithoutAlunoInput = {
    feito?: boolean | null
    revisar?: boolean | null
    aula: aulaCreateNestedOneWithoutFeitoInput
  }

  export type feitoUncheckedCreateWithoutAlunoInput = {
    id?: number
    feito?: boolean | null
    revisar?: boolean | null
    aula_id: number
  }

  export type feitoCreateOrConnectWithoutAlunoInput = {
    where: feitoWhereUniqueInput
    create: XOR<feitoCreateWithoutAlunoInput, feitoUncheckedCreateWithoutAlunoInput>
  }

  export type feitoCreateManyAlunoInputEnvelope = {
    data: feitoCreateManyAlunoInput | feitoCreateManyAlunoInput[]
    skipDuplicates?: boolean
  }

  export type turmaUpsertWithoutAlunoInput = {
    update: XOR<turmaUpdateWithoutAlunoInput, turmaUncheckedUpdateWithoutAlunoInput>
    create: XOR<turmaCreateWithoutAlunoInput, turmaUncheckedCreateWithoutAlunoInput>
    where?: turmaWhereInput
  }

  export type turmaUpdateToOneWithWhereWithoutAlunoInput = {
    where?: turmaWhereInput
    data: XOR<turmaUpdateWithoutAlunoInput, turmaUncheckedUpdateWithoutAlunoInput>
  }

  export type turmaUpdateWithoutAlunoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    modulo?: moduloUpdateManyWithoutTurmaNestedInput
    professor?: professorUpdateManyWithoutTurmaNestedInput
  }

  export type turmaUncheckedUpdateWithoutAlunoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    modulo?: moduloUncheckedUpdateManyWithoutTurmaNestedInput
    professor?: professorUncheckedUpdateManyWithoutTurmaNestedInput
  }

  export type usuarioUpsertWithoutAlunoInput = {
    update: XOR<usuarioUpdateWithoutAlunoInput, usuarioUncheckedUpdateWithoutAlunoInput>
    create: XOR<usuarioCreateWithoutAlunoInput, usuarioUncheckedCreateWithoutAlunoInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutAlunoInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutAlunoInput, usuarioUncheckedUpdateWithoutAlunoInput>
  }

  export type usuarioUpdateWithoutAlunoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    professor?: professorUpdateManyWithoutUsuarioNestedInput
    grupo?: grupoUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutAlunoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    grupo_id?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    professor?: professorUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type feitoUpsertWithWhereUniqueWithoutAlunoInput = {
    where: feitoWhereUniqueInput
    update: XOR<feitoUpdateWithoutAlunoInput, feitoUncheckedUpdateWithoutAlunoInput>
    create: XOR<feitoCreateWithoutAlunoInput, feitoUncheckedCreateWithoutAlunoInput>
  }

  export type feitoUpdateWithWhereUniqueWithoutAlunoInput = {
    where: feitoWhereUniqueInput
    data: XOR<feitoUpdateWithoutAlunoInput, feitoUncheckedUpdateWithoutAlunoInput>
  }

  export type feitoUpdateManyWithWhereWithoutAlunoInput = {
    where: feitoScalarWhereInput
    data: XOR<feitoUpdateManyMutationInput, feitoUncheckedUpdateManyWithoutAlunoInput>
  }

  export type feitoScalarWhereInput = {
    AND?: feitoScalarWhereInput | feitoScalarWhereInput[]
    OR?: feitoScalarWhereInput[]
    NOT?: feitoScalarWhereInput | feitoScalarWhereInput[]
    id?: IntFilter<"feito"> | number
    feito?: BoolNullableFilter<"feito"> | boolean | null
    revisar?: BoolNullableFilter<"feito"> | boolean | null
    aula_id?: IntFilter<"feito"> | number
    aluno_id?: IntFilter<"feito"> | number
  }

  export type moduloCreateWithoutAulaInput = {
    id?: number
    titulo: string
    image?: string | null
    descricao?: string | null
    turma: turmaCreateNestedOneWithoutModuloInput
  }

  export type moduloUncheckedCreateWithoutAulaInput = {
    id?: number
    turma_id: number
    titulo: string
    image?: string | null
    descricao?: string | null
  }

  export type moduloCreateOrConnectWithoutAulaInput = {
    where: moduloWhereUniqueInput
    create: XOR<moduloCreateWithoutAulaInput, moduloUncheckedCreateWithoutAulaInput>
  }

  export type feitoCreateWithoutAulaInput = {
    feito?: boolean | null
    revisar?: boolean | null
    aluno: alunoCreateNestedOneWithoutFeitoInput
  }

  export type feitoUncheckedCreateWithoutAulaInput = {
    id?: number
    feito?: boolean | null
    revisar?: boolean | null
    aluno_id: number
  }

  export type feitoCreateOrConnectWithoutAulaInput = {
    where: feitoWhereUniqueInput
    create: XOR<feitoCreateWithoutAulaInput, feitoUncheckedCreateWithoutAulaInput>
  }

  export type feitoCreateManyAulaInputEnvelope = {
    data: feitoCreateManyAulaInput | feitoCreateManyAulaInput[]
    skipDuplicates?: boolean
  }

  export type moduloUpsertWithoutAulaInput = {
    update: XOR<moduloUpdateWithoutAulaInput, moduloUncheckedUpdateWithoutAulaInput>
    create: XOR<moduloCreateWithoutAulaInput, moduloUncheckedCreateWithoutAulaInput>
    where?: moduloWhereInput
  }

  export type moduloUpdateToOneWithWhereWithoutAulaInput = {
    where?: moduloWhereInput
    data: XOR<moduloUpdateWithoutAulaInput, moduloUncheckedUpdateWithoutAulaInput>
  }

  export type moduloUpdateWithoutAulaInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    turma?: turmaUpdateOneRequiredWithoutModuloNestedInput
  }

  export type moduloUncheckedUpdateWithoutAulaInput = {
    id?: IntFieldUpdateOperationsInput | number
    turma_id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type feitoUpsertWithWhereUniqueWithoutAulaInput = {
    where: feitoWhereUniqueInput
    update: XOR<feitoUpdateWithoutAulaInput, feitoUncheckedUpdateWithoutAulaInput>
    create: XOR<feitoCreateWithoutAulaInput, feitoUncheckedCreateWithoutAulaInput>
  }

  export type feitoUpdateWithWhereUniqueWithoutAulaInput = {
    where: feitoWhereUniqueInput
    data: XOR<feitoUpdateWithoutAulaInput, feitoUncheckedUpdateWithoutAulaInput>
  }

  export type feitoUpdateManyWithWhereWithoutAulaInput = {
    where: feitoScalarWhereInput
    data: XOR<feitoUpdateManyMutationInput, feitoUncheckedUpdateManyWithoutAulaInput>
  }

  export type alunoCreateWithoutFeitoInput = {
    id?: number
    turma: turmaCreateNestedOneWithoutAlunoInput
    usuario: usuarioCreateNestedOneWithoutAlunoInput
  }

  export type alunoUncheckedCreateWithoutFeitoInput = {
    id?: number
    usuario_id: number
    turma_id: number
  }

  export type alunoCreateOrConnectWithoutFeitoInput = {
    where: alunoWhereUniqueInput
    create: XOR<alunoCreateWithoutFeitoInput, alunoUncheckedCreateWithoutFeitoInput>
  }

  export type aulaCreateWithoutFeitoInput = {
    id?: number
    titulo?: string | null
    video: string
    pdf_questoes?: string | null
    pdf_resolucao?: string | null
    descricao?: string | null
    modulo: moduloCreateNestedOneWithoutAulaInput
  }

  export type aulaUncheckedCreateWithoutFeitoInput = {
    id?: number
    modulo_id: number
    titulo?: string | null
    video: string
    pdf_questoes?: string | null
    pdf_resolucao?: string | null
    descricao?: string | null
  }

  export type aulaCreateOrConnectWithoutFeitoInput = {
    where: aulaWhereUniqueInput
    create: XOR<aulaCreateWithoutFeitoInput, aulaUncheckedCreateWithoutFeitoInput>
  }

  export type alunoUpsertWithoutFeitoInput = {
    update: XOR<alunoUpdateWithoutFeitoInput, alunoUncheckedUpdateWithoutFeitoInput>
    create: XOR<alunoCreateWithoutFeitoInput, alunoUncheckedCreateWithoutFeitoInput>
    where?: alunoWhereInput
  }

  export type alunoUpdateToOneWithWhereWithoutFeitoInput = {
    where?: alunoWhereInput
    data: XOR<alunoUpdateWithoutFeitoInput, alunoUncheckedUpdateWithoutFeitoInput>
  }

  export type alunoUpdateWithoutFeitoInput = {
    turma?: turmaUpdateOneRequiredWithoutAlunoNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutAlunoNestedInput
  }

  export type alunoUncheckedUpdateWithoutFeitoInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    turma_id?: IntFieldUpdateOperationsInput | number
  }

  export type aulaUpsertWithoutFeitoInput = {
    update: XOR<aulaUpdateWithoutFeitoInput, aulaUncheckedUpdateWithoutFeitoInput>
    create: XOR<aulaCreateWithoutFeitoInput, aulaUncheckedCreateWithoutFeitoInput>
    where?: aulaWhereInput
  }

  export type aulaUpdateToOneWithWhereWithoutFeitoInput = {
    where?: aulaWhereInput
    data: XOR<aulaUpdateWithoutFeitoInput, aulaUncheckedUpdateWithoutFeitoInput>
  }

  export type aulaUpdateWithoutFeitoInput = {
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    video?: StringFieldUpdateOperationsInput | string
    pdf_questoes?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    modulo?: moduloUpdateOneRequiredWithoutAulaNestedInput
  }

  export type aulaUncheckedUpdateWithoutFeitoInput = {
    id?: IntFieldUpdateOperationsInput | number
    modulo_id?: IntFieldUpdateOperationsInput | number
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    video?: StringFieldUpdateOperationsInput | string
    pdf_questoes?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permissoesCreateWithoutGrupoInput = {
    rota: rotaCreateNestedOneWithoutPermissoesInput
  }

  export type permissoesUncheckedCreateWithoutGrupoInput = {
    rota_id: number
  }

  export type permissoesCreateOrConnectWithoutGrupoInput = {
    where: permissoesWhereUniqueInput
    create: XOR<permissoesCreateWithoutGrupoInput, permissoesUncheckedCreateWithoutGrupoInput>
  }

  export type permissoesCreateManyGrupoInputEnvelope = {
    data: permissoesCreateManyGrupoInput | permissoesCreateManyGrupoInput[]
    skipDuplicates?: boolean
  }

  export type usuarioCreateWithoutGrupoInput = {
    id?: number
    nome: string
    senha: string
    matricula: string
    active: boolean
    aluno?: alunoCreateNestedManyWithoutUsuarioInput
    professor?: professorCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutGrupoInput = {
    id?: number
    nome: string
    senha: string
    matricula: string
    active: boolean
    aluno?: alunoUncheckedCreateNestedManyWithoutUsuarioInput
    professor?: professorUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutGrupoInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutGrupoInput, usuarioUncheckedCreateWithoutGrupoInput>
  }

  export type usuarioCreateManyGrupoInputEnvelope = {
    data: usuarioCreateManyGrupoInput | usuarioCreateManyGrupoInput[]
    skipDuplicates?: boolean
  }

  export type permissoesUpsertWithWhereUniqueWithoutGrupoInput = {
    where: permissoesWhereUniqueInput
    update: XOR<permissoesUpdateWithoutGrupoInput, permissoesUncheckedUpdateWithoutGrupoInput>
    create: XOR<permissoesCreateWithoutGrupoInput, permissoesUncheckedCreateWithoutGrupoInput>
  }

  export type permissoesUpdateWithWhereUniqueWithoutGrupoInput = {
    where: permissoesWhereUniqueInput
    data: XOR<permissoesUpdateWithoutGrupoInput, permissoesUncheckedUpdateWithoutGrupoInput>
  }

  export type permissoesUpdateManyWithWhereWithoutGrupoInput = {
    where: permissoesScalarWhereInput
    data: XOR<permissoesUpdateManyMutationInput, permissoesUncheckedUpdateManyWithoutGrupoInput>
  }

  export type permissoesScalarWhereInput = {
    AND?: permissoesScalarWhereInput | permissoesScalarWhereInput[]
    OR?: permissoesScalarWhereInput[]
    NOT?: permissoesScalarWhereInput | permissoesScalarWhereInput[]
    rota_id?: IntFilter<"permissoes"> | number
    grupo_id?: IntFilter<"permissoes"> | number
  }

  export type usuarioUpsertWithWhereUniqueWithoutGrupoInput = {
    where: usuarioWhereUniqueInput
    update: XOR<usuarioUpdateWithoutGrupoInput, usuarioUncheckedUpdateWithoutGrupoInput>
    create: XOR<usuarioCreateWithoutGrupoInput, usuarioUncheckedCreateWithoutGrupoInput>
  }

  export type usuarioUpdateWithWhereUniqueWithoutGrupoInput = {
    where: usuarioWhereUniqueInput
    data: XOR<usuarioUpdateWithoutGrupoInput, usuarioUncheckedUpdateWithoutGrupoInput>
  }

  export type usuarioUpdateManyWithWhereWithoutGrupoInput = {
    where: usuarioScalarWhereInput
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyWithoutGrupoInput>
  }

  export type usuarioScalarWhereInput = {
    AND?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
    OR?: usuarioScalarWhereInput[]
    NOT?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
    id?: IntFilter<"usuario"> | number
    nome?: StringFilter<"usuario"> | string
    grupo_id?: IntFilter<"usuario"> | number
    senha?: StringFilter<"usuario"> | string
    matricula?: StringFilter<"usuario"> | string
    active?: BoolFilter<"usuario"> | boolean
  }

  export type aulaCreateWithoutModuloInput = {
    id?: number
    titulo?: string | null
    video: string
    pdf_questoes?: string | null
    pdf_resolucao?: string | null
    descricao?: string | null
    feito?: feitoCreateNestedManyWithoutAulaInput
  }

  export type aulaUncheckedCreateWithoutModuloInput = {
    id?: number
    titulo?: string | null
    video: string
    pdf_questoes?: string | null
    pdf_resolucao?: string | null
    descricao?: string | null
    feito?: feitoUncheckedCreateNestedManyWithoutAulaInput
  }

  export type aulaCreateOrConnectWithoutModuloInput = {
    where: aulaWhereUniqueInput
    create: XOR<aulaCreateWithoutModuloInput, aulaUncheckedCreateWithoutModuloInput>
  }

  export type aulaCreateManyModuloInputEnvelope = {
    data: aulaCreateManyModuloInput | aulaCreateManyModuloInput[]
    skipDuplicates?: boolean
  }

  export type turmaCreateWithoutModuloInput = {
    nome: string
    aluno?: alunoCreateNestedManyWithoutTurmaInput
    professor?: professorCreateNestedManyWithoutTurmaInput
  }

  export type turmaUncheckedCreateWithoutModuloInput = {
    id?: number
    nome: string
    aluno?: alunoUncheckedCreateNestedManyWithoutTurmaInput
    professor?: professorUncheckedCreateNestedManyWithoutTurmaInput
  }

  export type turmaCreateOrConnectWithoutModuloInput = {
    where: turmaWhereUniqueInput
    create: XOR<turmaCreateWithoutModuloInput, turmaUncheckedCreateWithoutModuloInput>
  }

  export type aulaUpsertWithWhereUniqueWithoutModuloInput = {
    where: aulaWhereUniqueInput
    update: XOR<aulaUpdateWithoutModuloInput, aulaUncheckedUpdateWithoutModuloInput>
    create: XOR<aulaCreateWithoutModuloInput, aulaUncheckedCreateWithoutModuloInput>
  }

  export type aulaUpdateWithWhereUniqueWithoutModuloInput = {
    where: aulaWhereUniqueInput
    data: XOR<aulaUpdateWithoutModuloInput, aulaUncheckedUpdateWithoutModuloInput>
  }

  export type aulaUpdateManyWithWhereWithoutModuloInput = {
    where: aulaScalarWhereInput
    data: XOR<aulaUpdateManyMutationInput, aulaUncheckedUpdateManyWithoutModuloInput>
  }

  export type aulaScalarWhereInput = {
    AND?: aulaScalarWhereInput | aulaScalarWhereInput[]
    OR?: aulaScalarWhereInput[]
    NOT?: aulaScalarWhereInput | aulaScalarWhereInput[]
    id?: IntFilter<"aula"> | number
    modulo_id?: IntFilter<"aula"> | number
    titulo?: StringNullableFilter<"aula"> | string | null
    video?: StringFilter<"aula"> | string
    pdf_questoes?: StringNullableFilter<"aula"> | string | null
    pdf_resolucao?: StringNullableFilter<"aula"> | string | null
    descricao?: StringNullableFilter<"aula"> | string | null
  }

  export type turmaUpsertWithoutModuloInput = {
    update: XOR<turmaUpdateWithoutModuloInput, turmaUncheckedUpdateWithoutModuloInput>
    create: XOR<turmaCreateWithoutModuloInput, turmaUncheckedCreateWithoutModuloInput>
    where?: turmaWhereInput
  }

  export type turmaUpdateToOneWithWhereWithoutModuloInput = {
    where?: turmaWhereInput
    data: XOR<turmaUpdateWithoutModuloInput, turmaUncheckedUpdateWithoutModuloInput>
  }

  export type turmaUpdateWithoutModuloInput = {
    nome?: StringFieldUpdateOperationsInput | string
    aluno?: alunoUpdateManyWithoutTurmaNestedInput
    professor?: professorUpdateManyWithoutTurmaNestedInput
  }

  export type turmaUncheckedUpdateWithoutModuloInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    aluno?: alunoUncheckedUpdateManyWithoutTurmaNestedInput
    professor?: professorUncheckedUpdateManyWithoutTurmaNestedInput
  }

  export type grupoCreateWithoutPermissoesInput = {
    nome: string
    usuario?: usuarioCreateNestedManyWithoutGrupoInput
  }

  export type grupoUncheckedCreateWithoutPermissoesInput = {
    id?: number
    nome: string
    usuario?: usuarioUncheckedCreateNestedManyWithoutGrupoInput
  }

  export type grupoCreateOrConnectWithoutPermissoesInput = {
    where: grupoWhereUniqueInput
    create: XOR<grupoCreateWithoutPermissoesInput, grupoUncheckedCreateWithoutPermissoesInput>
  }

  export type rotaCreateWithoutPermissoesInput = {
    rota: string
    get: boolean
    post: boolean
    patch: boolean
    put: boolean
    delete: boolean
  }

  export type rotaUncheckedCreateWithoutPermissoesInput = {
    id?: number
    rota: string
    get: boolean
    post: boolean
    patch: boolean
    put: boolean
    delete: boolean
  }

  export type rotaCreateOrConnectWithoutPermissoesInput = {
    where: rotaWhereUniqueInput
    create: XOR<rotaCreateWithoutPermissoesInput, rotaUncheckedCreateWithoutPermissoesInput>
  }

  export type grupoUpsertWithoutPermissoesInput = {
    update: XOR<grupoUpdateWithoutPermissoesInput, grupoUncheckedUpdateWithoutPermissoesInput>
    create: XOR<grupoCreateWithoutPermissoesInput, grupoUncheckedCreateWithoutPermissoesInput>
    where?: grupoWhereInput
  }

  export type grupoUpdateToOneWithWhereWithoutPermissoesInput = {
    where?: grupoWhereInput
    data: XOR<grupoUpdateWithoutPermissoesInput, grupoUncheckedUpdateWithoutPermissoesInput>
  }

  export type grupoUpdateWithoutPermissoesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    usuario?: usuarioUpdateManyWithoutGrupoNestedInput
  }

  export type grupoUncheckedUpdateWithoutPermissoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    usuario?: usuarioUncheckedUpdateManyWithoutGrupoNestedInput
  }

  export type rotaUpsertWithoutPermissoesInput = {
    update: XOR<rotaUpdateWithoutPermissoesInput, rotaUncheckedUpdateWithoutPermissoesInput>
    create: XOR<rotaCreateWithoutPermissoesInput, rotaUncheckedCreateWithoutPermissoesInput>
    where?: rotaWhereInput
  }

  export type rotaUpdateToOneWithWhereWithoutPermissoesInput = {
    where?: rotaWhereInput
    data: XOR<rotaUpdateWithoutPermissoesInput, rotaUncheckedUpdateWithoutPermissoesInput>
  }

  export type rotaUpdateWithoutPermissoesInput = {
    rota?: StringFieldUpdateOperationsInput | string
    get?: BoolFieldUpdateOperationsInput | boolean
    post?: BoolFieldUpdateOperationsInput | boolean
    patch?: BoolFieldUpdateOperationsInput | boolean
    put?: BoolFieldUpdateOperationsInput | boolean
    delete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type rotaUncheckedUpdateWithoutPermissoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    rota?: StringFieldUpdateOperationsInput | string
    get?: BoolFieldUpdateOperationsInput | boolean
    post?: BoolFieldUpdateOperationsInput | boolean
    patch?: BoolFieldUpdateOperationsInput | boolean
    put?: BoolFieldUpdateOperationsInput | boolean
    delete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type turmaCreateWithoutProfessorInput = {
    nome: string
    aluno?: alunoCreateNestedManyWithoutTurmaInput
    modulo?: moduloCreateNestedManyWithoutTurmaInput
  }

  export type turmaUncheckedCreateWithoutProfessorInput = {
    id?: number
    nome: string
    aluno?: alunoUncheckedCreateNestedManyWithoutTurmaInput
    modulo?: moduloUncheckedCreateNestedManyWithoutTurmaInput
  }

  export type turmaCreateOrConnectWithoutProfessorInput = {
    where: turmaWhereUniqueInput
    create: XOR<turmaCreateWithoutProfessorInput, turmaUncheckedCreateWithoutProfessorInput>
  }

  export type usuarioCreateWithoutProfessorInput = {
    id?: number
    nome: string
    senha: string
    matricula: string
    active: boolean
    aluno?: alunoCreateNestedManyWithoutUsuarioInput
    grupo: grupoCreateNestedOneWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutProfessorInput = {
    id?: number
    nome: string
    grupo_id: number
    senha: string
    matricula: string
    active: boolean
    aluno?: alunoUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutProfessorInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutProfessorInput, usuarioUncheckedCreateWithoutProfessorInput>
  }

  export type turmaUpsertWithoutProfessorInput = {
    update: XOR<turmaUpdateWithoutProfessorInput, turmaUncheckedUpdateWithoutProfessorInput>
    create: XOR<turmaCreateWithoutProfessorInput, turmaUncheckedCreateWithoutProfessorInput>
    where?: turmaWhereInput
  }

  export type turmaUpdateToOneWithWhereWithoutProfessorInput = {
    where?: turmaWhereInput
    data: XOR<turmaUpdateWithoutProfessorInput, turmaUncheckedUpdateWithoutProfessorInput>
  }

  export type turmaUpdateWithoutProfessorInput = {
    nome?: StringFieldUpdateOperationsInput | string
    aluno?: alunoUpdateManyWithoutTurmaNestedInput
    modulo?: moduloUpdateManyWithoutTurmaNestedInput
  }

  export type turmaUncheckedUpdateWithoutProfessorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    aluno?: alunoUncheckedUpdateManyWithoutTurmaNestedInput
    modulo?: moduloUncheckedUpdateManyWithoutTurmaNestedInput
  }

  export type usuarioUpsertWithoutProfessorInput = {
    update: XOR<usuarioUpdateWithoutProfessorInput, usuarioUncheckedUpdateWithoutProfessorInput>
    create: XOR<usuarioCreateWithoutProfessorInput, usuarioUncheckedCreateWithoutProfessorInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutProfessorInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutProfessorInput, usuarioUncheckedUpdateWithoutProfessorInput>
  }

  export type usuarioUpdateWithoutProfessorInput = {
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    aluno?: alunoUpdateManyWithoutUsuarioNestedInput
    grupo?: grupoUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutProfessorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    grupo_id?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    aluno?: alunoUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type permissoesCreateWithoutRotaInput = {
    grupo: grupoCreateNestedOneWithoutPermissoesInput
  }

  export type permissoesUncheckedCreateWithoutRotaInput = {
    grupo_id: number
  }

  export type permissoesCreateOrConnectWithoutRotaInput = {
    where: permissoesWhereUniqueInput
    create: XOR<permissoesCreateWithoutRotaInput, permissoesUncheckedCreateWithoutRotaInput>
  }

  export type permissoesCreateManyRotaInputEnvelope = {
    data: permissoesCreateManyRotaInput | permissoesCreateManyRotaInput[]
    skipDuplicates?: boolean
  }

  export type permissoesUpsertWithWhereUniqueWithoutRotaInput = {
    where: permissoesWhereUniqueInput
    update: XOR<permissoesUpdateWithoutRotaInput, permissoesUncheckedUpdateWithoutRotaInput>
    create: XOR<permissoesCreateWithoutRotaInput, permissoesUncheckedCreateWithoutRotaInput>
  }

  export type permissoesUpdateWithWhereUniqueWithoutRotaInput = {
    where: permissoesWhereUniqueInput
    data: XOR<permissoesUpdateWithoutRotaInput, permissoesUncheckedUpdateWithoutRotaInput>
  }

  export type permissoesUpdateManyWithWhereWithoutRotaInput = {
    where: permissoesScalarWhereInput
    data: XOR<permissoesUpdateManyMutationInput, permissoesUncheckedUpdateManyWithoutRotaInput>
  }

  export type alunoCreateWithoutTurmaInput = {
    id?: number
    usuario: usuarioCreateNestedOneWithoutAlunoInput
    feito?: feitoCreateNestedManyWithoutAlunoInput
  }

  export type alunoUncheckedCreateWithoutTurmaInput = {
    id?: number
    usuario_id: number
    feito?: feitoUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type alunoCreateOrConnectWithoutTurmaInput = {
    where: alunoWhereUniqueInput
    create: XOR<alunoCreateWithoutTurmaInput, alunoUncheckedCreateWithoutTurmaInput>
  }

  export type alunoCreateManyTurmaInputEnvelope = {
    data: alunoCreateManyTurmaInput | alunoCreateManyTurmaInput[]
    skipDuplicates?: boolean
  }

  export type moduloCreateWithoutTurmaInput = {
    id?: number
    titulo: string
    image?: string | null
    descricao?: string | null
    aula?: aulaCreateNestedManyWithoutModuloInput
  }

  export type moduloUncheckedCreateWithoutTurmaInput = {
    id?: number
    titulo: string
    image?: string | null
    descricao?: string | null
    aula?: aulaUncheckedCreateNestedManyWithoutModuloInput
  }

  export type moduloCreateOrConnectWithoutTurmaInput = {
    where: moduloWhereUniqueInput
    create: XOR<moduloCreateWithoutTurmaInput, moduloUncheckedCreateWithoutTurmaInput>
  }

  export type moduloCreateManyTurmaInputEnvelope = {
    data: moduloCreateManyTurmaInput | moduloCreateManyTurmaInput[]
    skipDuplicates?: boolean
  }

  export type professorCreateWithoutTurmaInput = {
    id?: number
    usuario: usuarioCreateNestedOneWithoutProfessorInput
  }

  export type professorUncheckedCreateWithoutTurmaInput = {
    id?: number
    usuario_id: number
  }

  export type professorCreateOrConnectWithoutTurmaInput = {
    where: professorWhereUniqueInput
    create: XOR<professorCreateWithoutTurmaInput, professorUncheckedCreateWithoutTurmaInput>
  }

  export type professorCreateManyTurmaInputEnvelope = {
    data: professorCreateManyTurmaInput | professorCreateManyTurmaInput[]
    skipDuplicates?: boolean
  }

  export type alunoUpsertWithWhereUniqueWithoutTurmaInput = {
    where: alunoWhereUniqueInput
    update: XOR<alunoUpdateWithoutTurmaInput, alunoUncheckedUpdateWithoutTurmaInput>
    create: XOR<alunoCreateWithoutTurmaInput, alunoUncheckedCreateWithoutTurmaInput>
  }

  export type alunoUpdateWithWhereUniqueWithoutTurmaInput = {
    where: alunoWhereUniqueInput
    data: XOR<alunoUpdateWithoutTurmaInput, alunoUncheckedUpdateWithoutTurmaInput>
  }

  export type alunoUpdateManyWithWhereWithoutTurmaInput = {
    where: alunoScalarWhereInput
    data: XOR<alunoUpdateManyMutationInput, alunoUncheckedUpdateManyWithoutTurmaInput>
  }

  export type alunoScalarWhereInput = {
    AND?: alunoScalarWhereInput | alunoScalarWhereInput[]
    OR?: alunoScalarWhereInput[]
    NOT?: alunoScalarWhereInput | alunoScalarWhereInput[]
    id?: IntFilter<"aluno"> | number
    usuario_id?: IntFilter<"aluno"> | number
    turma_id?: IntFilter<"aluno"> | number
  }

  export type moduloUpsertWithWhereUniqueWithoutTurmaInput = {
    where: moduloWhereUniqueInput
    update: XOR<moduloUpdateWithoutTurmaInput, moduloUncheckedUpdateWithoutTurmaInput>
    create: XOR<moduloCreateWithoutTurmaInput, moduloUncheckedCreateWithoutTurmaInput>
  }

  export type moduloUpdateWithWhereUniqueWithoutTurmaInput = {
    where: moduloWhereUniqueInput
    data: XOR<moduloUpdateWithoutTurmaInput, moduloUncheckedUpdateWithoutTurmaInput>
  }

  export type moduloUpdateManyWithWhereWithoutTurmaInput = {
    where: moduloScalarWhereInput
    data: XOR<moduloUpdateManyMutationInput, moduloUncheckedUpdateManyWithoutTurmaInput>
  }

  export type moduloScalarWhereInput = {
    AND?: moduloScalarWhereInput | moduloScalarWhereInput[]
    OR?: moduloScalarWhereInput[]
    NOT?: moduloScalarWhereInput | moduloScalarWhereInput[]
    id?: IntFilter<"modulo"> | number
    turma_id?: IntFilter<"modulo"> | number
    titulo?: StringFilter<"modulo"> | string
    image?: StringNullableFilter<"modulo"> | string | null
    descricao?: StringNullableFilter<"modulo"> | string | null
  }

  export type professorUpsertWithWhereUniqueWithoutTurmaInput = {
    where: professorWhereUniqueInput
    update: XOR<professorUpdateWithoutTurmaInput, professorUncheckedUpdateWithoutTurmaInput>
    create: XOR<professorCreateWithoutTurmaInput, professorUncheckedCreateWithoutTurmaInput>
  }

  export type professorUpdateWithWhereUniqueWithoutTurmaInput = {
    where: professorWhereUniqueInput
    data: XOR<professorUpdateWithoutTurmaInput, professorUncheckedUpdateWithoutTurmaInput>
  }

  export type professorUpdateManyWithWhereWithoutTurmaInput = {
    where: professorScalarWhereInput
    data: XOR<professorUpdateManyMutationInput, professorUncheckedUpdateManyWithoutTurmaInput>
  }

  export type professorScalarWhereInput = {
    AND?: professorScalarWhereInput | professorScalarWhereInput[]
    OR?: professorScalarWhereInput[]
    NOT?: professorScalarWhereInput | professorScalarWhereInput[]
    id?: IntFilter<"professor"> | number
    turma_id?: IntFilter<"professor"> | number
    usuario_id?: IntFilter<"professor"> | number
  }

  export type alunoCreateWithoutUsuarioInput = {
    id?: number
    turma: turmaCreateNestedOneWithoutAlunoInput
    feito?: feitoCreateNestedManyWithoutAlunoInput
  }

  export type alunoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    turma_id: number
    feito?: feitoUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type alunoCreateOrConnectWithoutUsuarioInput = {
    where: alunoWhereUniqueInput
    create: XOR<alunoCreateWithoutUsuarioInput, alunoUncheckedCreateWithoutUsuarioInput>
  }

  export type alunoCreateManyUsuarioInputEnvelope = {
    data: alunoCreateManyUsuarioInput | alunoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type professorCreateWithoutUsuarioInput = {
    id?: number
    turma: turmaCreateNestedOneWithoutProfessorInput
  }

  export type professorUncheckedCreateWithoutUsuarioInput = {
    id?: number
    turma_id: number
  }

  export type professorCreateOrConnectWithoutUsuarioInput = {
    where: professorWhereUniqueInput
    create: XOR<professorCreateWithoutUsuarioInput, professorUncheckedCreateWithoutUsuarioInput>
  }

  export type professorCreateManyUsuarioInputEnvelope = {
    data: professorCreateManyUsuarioInput | professorCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type grupoCreateWithoutUsuarioInput = {
    nome: string
    permissoes?: permissoesCreateNestedManyWithoutGrupoInput
  }

  export type grupoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    nome: string
    permissoes?: permissoesUncheckedCreateNestedManyWithoutGrupoInput
  }

  export type grupoCreateOrConnectWithoutUsuarioInput = {
    where: grupoWhereUniqueInput
    create: XOR<grupoCreateWithoutUsuarioInput, grupoUncheckedCreateWithoutUsuarioInput>
  }

  export type alunoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: alunoWhereUniqueInput
    update: XOR<alunoUpdateWithoutUsuarioInput, alunoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<alunoCreateWithoutUsuarioInput, alunoUncheckedCreateWithoutUsuarioInput>
  }

  export type alunoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: alunoWhereUniqueInput
    data: XOR<alunoUpdateWithoutUsuarioInput, alunoUncheckedUpdateWithoutUsuarioInput>
  }

  export type alunoUpdateManyWithWhereWithoutUsuarioInput = {
    where: alunoScalarWhereInput
    data: XOR<alunoUpdateManyMutationInput, alunoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type professorUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: professorWhereUniqueInput
    update: XOR<professorUpdateWithoutUsuarioInput, professorUncheckedUpdateWithoutUsuarioInput>
    create: XOR<professorCreateWithoutUsuarioInput, professorUncheckedCreateWithoutUsuarioInput>
  }

  export type professorUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: professorWhereUniqueInput
    data: XOR<professorUpdateWithoutUsuarioInput, professorUncheckedUpdateWithoutUsuarioInput>
  }

  export type professorUpdateManyWithWhereWithoutUsuarioInput = {
    where: professorScalarWhereInput
    data: XOR<professorUpdateManyMutationInput, professorUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type grupoUpsertWithoutUsuarioInput = {
    update: XOR<grupoUpdateWithoutUsuarioInput, grupoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<grupoCreateWithoutUsuarioInput, grupoUncheckedCreateWithoutUsuarioInput>
    where?: grupoWhereInput
  }

  export type grupoUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: grupoWhereInput
    data: XOR<grupoUpdateWithoutUsuarioInput, grupoUncheckedUpdateWithoutUsuarioInput>
  }

  export type grupoUpdateWithoutUsuarioInput = {
    nome?: StringFieldUpdateOperationsInput | string
    permissoes?: permissoesUpdateManyWithoutGrupoNestedInput
  }

  export type grupoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    permissoes?: permissoesUncheckedUpdateManyWithoutGrupoNestedInput
  }

  export type feitoCreateManyAlunoInput = {
    id?: number
    feito?: boolean | null
    revisar?: boolean | null
    aula_id: number
  }

  export type feitoUpdateWithoutAlunoInput = {
    feito?: NullableBoolFieldUpdateOperationsInput | boolean | null
    revisar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aula?: aulaUpdateOneRequiredWithoutFeitoNestedInput
  }

  export type feitoUncheckedUpdateWithoutAlunoInput = {
    id?: IntFieldUpdateOperationsInput | number
    feito?: NullableBoolFieldUpdateOperationsInput | boolean | null
    revisar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aula_id?: IntFieldUpdateOperationsInput | number
  }

  export type feitoUncheckedUpdateManyWithoutAlunoInput = {
    id?: IntFieldUpdateOperationsInput | number
    feito?: NullableBoolFieldUpdateOperationsInput | boolean | null
    revisar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aula_id?: IntFieldUpdateOperationsInput | number
  }

  export type feitoCreateManyAulaInput = {
    id?: number
    feito?: boolean | null
    revisar?: boolean | null
    aluno_id: number
  }

  export type feitoUpdateWithoutAulaInput = {
    feito?: NullableBoolFieldUpdateOperationsInput | boolean | null
    revisar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aluno?: alunoUpdateOneRequiredWithoutFeitoNestedInput
  }

  export type feitoUncheckedUpdateWithoutAulaInput = {
    id?: IntFieldUpdateOperationsInput | number
    feito?: NullableBoolFieldUpdateOperationsInput | boolean | null
    revisar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aluno_id?: IntFieldUpdateOperationsInput | number
  }

  export type feitoUncheckedUpdateManyWithoutAulaInput = {
    id?: IntFieldUpdateOperationsInput | number
    feito?: NullableBoolFieldUpdateOperationsInput | boolean | null
    revisar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aluno_id?: IntFieldUpdateOperationsInput | number
  }

  export type permissoesCreateManyGrupoInput = {
    rota_id: number
  }

  export type usuarioCreateManyGrupoInput = {
    id?: number
    nome: string
    senha: string
    matricula: string
    active: boolean
  }

  export type permissoesUpdateWithoutGrupoInput = {
    rota?: rotaUpdateOneRequiredWithoutPermissoesNestedInput
  }

  export type permissoesUncheckedUpdateWithoutGrupoInput = {
    rota_id?: IntFieldUpdateOperationsInput | number
  }

  export type permissoesUncheckedUpdateManyWithoutGrupoInput = {
    rota_id?: IntFieldUpdateOperationsInput | number
  }

  export type usuarioUpdateWithoutGrupoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    aluno?: alunoUpdateManyWithoutUsuarioNestedInput
    professor?: professorUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutGrupoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    aluno?: alunoUncheckedUpdateManyWithoutUsuarioNestedInput
    professor?: professorUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateManyWithoutGrupoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type aulaCreateManyModuloInput = {
    id?: number
    titulo?: string | null
    video: string
    pdf_questoes?: string | null
    pdf_resolucao?: string | null
    descricao?: string | null
  }

  export type aulaUpdateWithoutModuloInput = {
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    video?: StringFieldUpdateOperationsInput | string
    pdf_questoes?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    feito?: feitoUpdateManyWithoutAulaNestedInput
  }

  export type aulaUncheckedUpdateWithoutModuloInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    video?: StringFieldUpdateOperationsInput | string
    pdf_questoes?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    feito?: feitoUncheckedUpdateManyWithoutAulaNestedInput
  }

  export type aulaUncheckedUpdateManyWithoutModuloInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    video?: StringFieldUpdateOperationsInput | string
    pdf_questoes?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permissoesCreateManyRotaInput = {
    grupo_id: number
  }

  export type permissoesUpdateWithoutRotaInput = {
    grupo?: grupoUpdateOneRequiredWithoutPermissoesNestedInput
  }

  export type permissoesUncheckedUpdateWithoutRotaInput = {
    grupo_id?: IntFieldUpdateOperationsInput | number
  }

  export type permissoesUncheckedUpdateManyWithoutRotaInput = {
    grupo_id?: IntFieldUpdateOperationsInput | number
  }

  export type alunoCreateManyTurmaInput = {
    id?: number
    usuario_id: number
  }

  export type moduloCreateManyTurmaInput = {
    id?: number
    titulo: string
    image?: string | null
    descricao?: string | null
  }

  export type professorCreateManyTurmaInput = {
    id?: number
    usuario_id: number
  }

  export type alunoUpdateWithoutTurmaInput = {
    usuario?: usuarioUpdateOneRequiredWithoutAlunoNestedInput
    feito?: feitoUpdateManyWithoutAlunoNestedInput
  }

  export type alunoUncheckedUpdateWithoutTurmaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    feito?: feitoUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type alunoUncheckedUpdateManyWithoutTurmaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type moduloUpdateWithoutTurmaInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    aula?: aulaUpdateManyWithoutModuloNestedInput
  }

  export type moduloUncheckedUpdateWithoutTurmaInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    aula?: aulaUncheckedUpdateManyWithoutModuloNestedInput
  }

  export type moduloUncheckedUpdateManyWithoutTurmaInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type professorUpdateWithoutTurmaInput = {
    usuario?: usuarioUpdateOneRequiredWithoutProfessorNestedInput
  }

  export type professorUncheckedUpdateWithoutTurmaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type professorUncheckedUpdateManyWithoutTurmaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type alunoCreateManyUsuarioInput = {
    id?: number
    turma_id: number
  }

  export type professorCreateManyUsuarioInput = {
    id?: number
    turma_id: number
  }

  export type alunoUpdateWithoutUsuarioInput = {
    turma?: turmaUpdateOneRequiredWithoutAlunoNestedInput
    feito?: feitoUpdateManyWithoutAlunoNestedInput
  }

  export type alunoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    turma_id?: IntFieldUpdateOperationsInput | number
    feito?: feitoUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type alunoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    turma_id?: IntFieldUpdateOperationsInput | number
  }

  export type professorUpdateWithoutUsuarioInput = {
    turma?: turmaUpdateOneRequiredWithoutProfessorNestedInput
  }

  export type professorUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    turma_id?: IntFieldUpdateOperationsInput | number
  }

  export type professorUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    turma_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AlunoCountOutputTypeDefaultArgs instead
     */
    export type AlunoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlunoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AulaCountOutputTypeDefaultArgs instead
     */
    export type AulaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AulaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GrupoCountOutputTypeDefaultArgs instead
     */
    export type GrupoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GrupoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuloCountOutputTypeDefaultArgs instead
     */
    export type ModuloCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuloCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RotaCountOutputTypeDefaultArgs instead
     */
    export type RotaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RotaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TurmaCountOutputTypeDefaultArgs instead
     */
    export type TurmaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TurmaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use alunoDefaultArgs instead
     */
    export type alunoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = alunoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use aulaDefaultArgs instead
     */
    export type aulaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = aulaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use feitoDefaultArgs instead
     */
    export type feitoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = feitoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use grupoDefaultArgs instead
     */
    export type grupoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = grupoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use moduloDefaultArgs instead
     */
    export type moduloArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = moduloDefaultArgs<ExtArgs>
    /**
     * @deprecated Use permissoesDefaultArgs instead
     */
    export type permissoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = permissoesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use professorDefaultArgs instead
     */
    export type professorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = professorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rotaDefaultArgs instead
     */
    export type rotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rotaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use turmaDefaultArgs instead
     */
    export type turmaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = turmaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usuarioDefaultArgs instead
     */
    export type usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usuarioDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}